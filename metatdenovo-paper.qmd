---
title: "nf-core/metatdenovo"
author: "danilo.dileo@lnu.se, emelie.nilsson@lnu.se, ..., daniel.lundin@lnu.se"
date: "`r format(Sys.time(), '%Y-%m-%d')`"
format:
  html:
    code-fold: true
    toc: true
  pdf:
    toc: true
    number-sections: true
    colorlinks: true
bibliography:
  - bibliography.bib
  - grateful-refs.bib
---

```{r setup}
#| label: setup
#| echo: false
#| cache: false

knitr::opts_chunk$set(echo = TRUE, fig.path='figures/', cache = TRUE, fig.width = 10)
ggplot2::theme_set(ggplot2::theme_bw())
```

```{r libraries}
#| label: libraries
#| message: false
#| cache: false
#| include: false

library(readr)
library(data.table)
library(dtplyr)
library(dplyr, warn.conflicts = FALSE)
library(tidyr)
library(lubridate)
library(purrr)
library(stringr)
library(ggplot2)
library(kfigr)
library(knitr)
library(DT)
library(grateful)
library(patchwork)
```

```{r constants}
#| label: constants

TAXON_RANKS_SORTED = c('root', 'domain', 'phylum', 'class', 'order', 'family', 'genus', 'species')
```

```{r read-execution-traces}
#| label: read-data
extraces <- Sys.glob('nextflow/*/*/pipeline_info/execution_trace*') %>%
  read_tsv(show_col_types = FALSE, id = 'fname') %>%
  mutate(
    project = str_replace(fname, 'nextflow\\/([^/]+)\\/.*', '\\1'),
    run     = str_remove(fname, 'nextflow\\/[^/]+\\/') %>% str_remove('\\/.*'),
    p       = str_remove(name, '.*:'),
    process = str_remove(p, ' .*'),
    sample  = str_replace(p, '.*\\((.*)\\)', '\\1'),
    durationc  = str_remove(duration, ' *\\d+ms') %>%
      ifelse(str_detect(., '\\dh'), ., str_c('0h', ., sep = ' ')) %>%
      ifelse(str_detect(., '\\dm'), ., str_c('0m', ., sep = ' ')) %>%
      ifelse(str_detect(., '\\ds'), ., str_c(., '0s', sep = ' ')) %>%
      hms(),
    realtimec  = str_remove(realtime, ' *\\d+ms') %>%
      ifelse(str_detect(., '\\dh'), ., str_c('0h', ., sep = ' ')) %>%
      ifelse(str_detect(., '\\dm'), ., str_c('0m', ., sep = ' ')) %>%
      ifelse(str_detect(., '\\ds'), ., str_c(., '0s', sep = ' ')) %>%
      hms(),
    peak_rssc = case_when(
      str_detect(peak_rss, 'GB') ~ str_remove(peak_rss, ' .*') %>% as.numeric() * 1024^3,
      str_detect(peak_rss, 'MB') ~ str_remove(peak_rss, ' .*') %>% as.numeric() * 1024^2,
      str_detect(peak_rss, 'KB') ~ str_remove(peak_rss, ' .*') %>% as.numeric() * 1024^1,
      str_detect(peak_rss, 'B')  ~ str_remove(peak_rss, ' .*') %>% as.numeric() * 1024^0,
      TRUE                       ~ 0
    ),
    peak_vmemc = case_when(
      str_detect(peak_vmem, 'GB') ~ str_remove(peak_rss, ' .*') %>% as.numeric() * 1024^3,
      str_detect(peak_vmem, 'MB') ~ str_remove(peak_rss, ' .*') %>% as.numeric() * 1024^2,
      str_detect(peak_vmem, 'KB') ~ str_remove(peak_rss, ' .*') %>% as.numeric() * 1024^1,
      str_detect(peak_vmem, 'B')  ~ str_remove(peak_rss, ' .*') %>% as.numeric() * 1024^0,
      TRUE                       ~ 0
    ),
    rcharc = case_when(
      str_detect(rchar, 'GB') ~ str_remove(peak_rss, ' .*') %>% as.numeric() * 1024^3,
      str_detect(rchar, 'MB') ~ str_remove(peak_rss, ' .*') %>% as.numeric() * 1024^2,
      str_detect(rchar, 'KB') ~ str_remove(peak_rss, ' .*') %>% as.numeric() * 1024^1,
      str_detect(rchar, 'B')  ~ str_remove(peak_rss, ' .*') %>% as.numeric() * 1024^0,
      TRUE                       ~ 0
    ),
    wcharc = case_when(
      str_detect(wchar, 'GB') ~ str_remove(peak_rss, ' .*') %>% as.numeric() * 1024^3,
      str_detect(wchar, 'MB') ~ str_remove(peak_rss, ' .*') %>% as.numeric() * 1024^2,
      str_detect(wchar, 'KB') ~ str_remove(peak_rss, ' .*') %>% as.numeric() * 1024^1,
      str_detect(wchar, 'B')  ~ str_remove(peak_rss, ' .*') %>% as.numeric() * 1024^0,
      TRUE                       ~ 0
    )
  ) %>%
  select(-p, -fname) %>%
  separate(run, c('assembler', 'orf_caller', 'bbnorm', 'minlen'), remove = FALSE, sep = '\\.', fill = 'right') %>%
  mutate(minlen = ifelse(is.na(minlen), 0, str_remove(minlen, 'minlen') %>% as.integer())) %>%
  mutate(assembly = sprintf("%s%s%s", assembler, ifelse(bbnorm == 'with_bbnorm', '*', ''), ifelse(minlen > 0, '†', ''))) %>%
  relocate(project, run, assembly, assembler, orf_caller, bbnorm, minlen, process, sample)

process_groups <- read_tsv('data/process_groups.tsv', show_col_types = FALSE)
```

```{r read-overall-stats}
#| label: read-overall-stats
#| warning: false
overall_stats <- Sys.glob('nextflow/*/*/summary_tables/*overall_stats.tsv.gz') %>%
  read_tsv(id = 'fname', show_col_types = FALSE) %>%
  mutate(
    project = str_replace(fname, 'nextflow\\/([^/]+)\\/.*', '\\1'),
    run     = str_remove(fname, 'nextflow\\/[^/]+\\/') %>% str_remove('\\/.*')
  ) %>%
  select(-fname) %>%
  separate(run, c('assembler', 'orf_caller', 'bbnorm', 'minlen'), remove = FALSE, sep = '\\.', fill = 'right') %>%
  mutate(minlen = ifelse(is.na(minlen), 0, str_remove(minlen, 'minlen') %>% as.integer())) %>%
  mutate(assembly = sprintf("%s%s%s", assembler, ifelse(bbnorm == 'with_bbnorm', '*', ''), ifelse(minlen > 0, '†', ''))) %>%
  relocate(project, run, assembly, assembler, orf_caller, bbnorm, minlen)
```

```{r read-transrate}
#| label: read-transrate
#| warning: false
transrates <- Sys.glob('nextflow/*/*/transrate/*.csv') %>%
  read_csv(id = 'fname', show_col_types = FALSE) %>%
  mutate(
    project = str_replace(fname, 'nextflow\\/([^/]+)\\/.*', '\\1'),
    run     = str_remove(fname, 'nextflow\\/[^/]+\\/') %>% str_remove('\\/.*')
  ) %>%
  separate(run, c('assembler', 'orf_caller', 'bbnorm', 'minlen'), remove = FALSE, sep = '\\.', fill = 'right') %>%
  select(-fname, -run, -orf_caller) %>%
  mutate(minlen = ifelse(is.na(minlen), 0, str_remove(minlen, 'minlen') %>% as.integer())) %>%
  mutate(assembly = sprintf("%s%s%s", assembler, ifelse(bbnorm == 'with_bbnorm', '*', ''), ifelse(minlen > 0, '†', ''))) %>%
  relocate(project, assembly, assembler, bbnorm, minlen) %>%
  distinct()
```

```{r read-idxstats}
#| label: read-idxstats

#idxstats <- Sys.glob('nextflow/*/*/samtools/*.KA1.idxstats') %>%
idxstats <- Sys.glob('nextflow/*/*/samtools/*.idxstats') %>%
  read_tsv(id = 'fname', show_col_types = FALSE, col_names = c('contig', 'length', 'n_mapped', 'n_unmapped')) %>%
  filter(contig != '*', n_mapped > 0) %>%
  mutate(
    project = str_replace(fname, 'nextflow\\/([^/]+)\\/.*', '\\1'),
    run     = str_remove(fname,  'nextflow\\/[^/]+\\/') %>% str_remove('\\/.*') %>% str_replace('^([^.]+)\\.[^.]+(.*)', '\\1\\2'),
    sample  = str_replace(fname, '.*\\.([^.]+).idxstats', '\\1')
  ) %>%
  select(-fname) %>%
  distinct() %>%
  mutate(r = n_mapped/length) %>%
  group_by(project, run, sample) %>%
  mutate(tpm = r/sum(r) * 1e6) %>%
  ungroup() %>%
  select(-r) %>%
  separate(run, c('assembler', 'bbnorm', 'minlen'), remove = FALSE, sep = '\\.', fill = 'right') %>%
  mutate(minlen = ifelse(is.na(minlen), 0, str_remove(minlen, 'minlen') %>% as.integer())) %>%
  mutate(assembly = sprintf("%s%s%s", assembler, ifelse(bbnorm == 'with_bbnorm', '*', ''), ifelse(minlen > 0, '†', ''))) %>%
  relocate(project, run, assembly, assembler, bbnorm, minlen, sample)
```

```{r read-counts}
#| label: read-counts
#| cache-lazy: false

counts <- Sys.glob('nextflow/*/*/summary_tables/*.counts.tsv.gz') %>%
  read_tsv(id = 'fname', show_col_types = FALSE) %>%
  mutate(
    project = str_replace(fname, 'nextflow\\/([^/]+)\\/.*', '\\1'),
    run     = str_remove(fname, 'nextflow\\/[^/]+\\/') %>% str_remove('\\/.*')
  ) %>%
  select(-fname) %>%
  separate(run, c('assembler', 'orf_caller', 'bbnorm', 'minlen'), remove = FALSE, sep = '\\.', fill = 'right') %>%
  mutate(minlen = ifelse(is.na(minlen), 0, str_remove(minlen, 'minlen') %>% as.integer())) %>%
  mutate(assembly = sprintf("%s%s%s", assembler, ifelse(bbnorm == 'with_bbnorm', '*', ''), ifelse(minlen > 0, '†', ''))) %>%
  relocate(project, run, assembly, assembler, orf_caller, bbnorm, minlen, sample)
```

```{r read-eukulele}
#| label: read-eukulele

eukulele <- Sys.glob('nextflow/*/*/summary_tables/*_taxonomy.tsv.gz') %>%
  read_tsv(id = 'fname', show_col_types = FALSE) %>%
  mutate(
    db      = str_replace(fname, 'nextflow\\/.*\\.(.*)_taxonomy.tsv.gz', '\\1'),
    project = str_replace(fname, 'nextflow\\/([^/]+)\\/.*', '\\1'),
    run     = str_remove(fname, 'nextflow\\/[^/]+\\/') %>% str_remove('\\/.*')
  ) %>%
  select(-fname) %>%
  separate(run, c('assembler', 'orf_caller', 'bbnorm', 'minlen'), remove = FALSE, sep = '\\.', fill = 'right') %>%
  mutate(minlen = ifelse(is.na(minlen), 0, str_remove(minlen, 'minlen') %>% as.integer())) %>%
  mutate(assembly = sprintf("%s%s%s", assembler, ifelse(bbnorm == 'with_bbnorm', '*', ''), ifelse(minlen > 0, '†', ''))) %>%
  relocate(project, run, assembly, assembler, orf_caller, bbnorm, minlen, db) %>%
  mutate(
    taxon_rank = case_when(
      str_detect(domain,  'uncl\\.')  ~ 'root',
      str_detect(phylum,  'uncl\\.')  ~ 'domain',
      str_detect(class,   'uncl\\.')  ~ 'phylum',
      str_detect(order,   'uncl\\.')  ~ 'class',
      str_detect(family,  'uncl\\.')  ~ 'order',
      str_detect(genus,   'uncl\\.')  ~ 'family',
      str_detect(species, 'uncl\\.')  ~ 'genus',
      TRUE                            ~ 'species'
    ) %>% factor(levels = TAXON_RANKS_SORTED, ordered = TRUE)
  )
```

```{r read-eggnogs}
#| label: read-eggnogs
#| cache-lazy: false

eggnogs <- Sys.glob('nextflow/*/*/summary_tables/*.emapper.tsv.gz') %>%
  read_tsv(id = 'fname', show_col_types = FALSE) %>%
  mutate(
    project = str_replace(fname, 'nextflow\\/([^/]+)\\/.*', '\\1'),
    run     = str_remove(fname, 'nextflow\\/[^/]+\\/') %>% str_remove('\\/.*')
  ) %>%
  select(-fname) %>%
  separate(run, c('assembler', 'orf_caller', 'bbnorm', 'minlen'), remove = FALSE, sep = '\\.', fill = 'right') %>%
  mutate(minlen = ifelse(is.na(minlen), 0, str_remove(minlen, 'minlen') %>% as.integer())) %>%
  mutate(assembly = sprintf("%s%s%s", assembler, ifelse(bbnorm == 'with_bbnorm', '*', ''), ifelse(minlen > 0, '†', ''))) %>%
  relocate(project, run, assembly, assembler, orf_caller, bbnorm, minlen)
```

```{r read-kofams}
#| label: read-kofams
#| cache-lazy: false

kofams <- Sys.glob('nextflow/*/*/summary_tables/*.kofamscan.tsv.gz') %>%
  read_tsv(id = 'fname', show_col_types = FALSE) %>%
  mutate(
    project = str_replace(fname, 'nextflow\\/([^/]+)\\/.*', '\\1'),
    run     = str_remove(fname, 'nextflow\\/[^/]+\\/') %>% str_remove('\\/.*')
  ) %>%
  select(-fname) %>%
  separate(run, c('assembler', 'orf_caller', 'bbnorm', 'minlen'), remove = FALSE, sep = '\\.', fill = 'right') %>%
  mutate(minlen = ifelse(is.na(minlen), 0, str_remove(minlen, 'minlen') %>% as.integer())) %>%
  mutate(assembly = sprintf("%s%s%s", assembler, ifelse(bbnorm == 'with_bbnorm', '*', ''), ifelse(minlen > 0, '†', ''))) %>%
  relocate(project, run, assembly, assembler, orf_caller, bbnorm, minlen)
```

```{r read-prokkas}
#| label: read-prokkas
#| cache-lazy: false

prokkas <- Sys.glob('nextflow/*/*/summary_tables/*.prokka-annotations.tsv.gz') %>%
  read_tsv(id = 'fname', show_col_types = FALSE, guess_max = 1e6) %>%
  mutate(
    project = str_replace(fname, 'nextflow\\/([^/]+)\\/.*', '\\1'),
    run     = str_remove(fname, 'nextflow\\/[^/]+\\/') %>% str_remove('\\/.*')
  ) %>%
  select(-fname) %>%
  separate(run, c('assembler', 'orf_caller', 'bbnorm', 'minlen'), remove = FALSE, sep = '\\.', fill = 'right') %>%
  mutate(minlen = ifelse(is.na(minlen), 0, str_remove(minlen, 'minlen') %>% as.integer())) %>%
  mutate(assembly = sprintf("%s%s%s", assembler, ifelse(bbnorm == 'with_bbnorm', '*', ''), ifelse(minlen > 0, '†', ''))) %>%
  relocate(project, run, assembly, assembler, orf_caller, bbnorm, minlen)
```

```{r func-annots}
#| label: func-annots

func_annots <- eggnogs %>% select(project:minlen, orf) %>% mutate(orf, annot = 'eggnog') %>% distinct() %>%
  union(
    kofams %>% select(project:minlen, orf) %>% mutate(orf, annot = 'kofam') %>% distinct()
  ) %>%
  union(
    prokkas %>% filter(product != 'hypothetical protein') %>% 
      select(project:minlen, orf) %>% mutate(orf, annot = 'prokka') %>% distinct()
  ) %>%
  pivot_wider(names_from = annot, values_from = annot) %>%
  unite(combination, c(eggnog, kofam, prokka), sep = '+', na.rm = TRUE)
```

```{r toporfs}
toporfs <- counts %>%
  filter(count >= 5) %>%
  group_by(project, run, assembly, assembler, orf_caller, bbnorm, minlen, orf) %>%
  summarise(max_tpm = max(tpm), n_samples = n(), .groups = 'drop') %>%
  filter(max_tpm > 1e5) %>%
  arrange(desc(max_tpm))
```

# Version history

# Summary

# Introduction

Cite nf-core [@nf-core].

# Materials and Methods

## R and packages

This analysis was run with `r R.version$version.string`. Versions of packages used can be found in Table @tbl-cite-packages.

```{r}
#| label: tbl-cite-packages
#| cache: false
#| tbl-cap: Versions of R and packages used in this analysis.

cite_packages(output = "table", pkgs = "Session", out.dir = getwd()) %>%
  kable()
```

# Results

## MST-1

### Resource usage and assembly quality with different parameter values

With the Bunse et al. dataset (REF) consisting of surface water prokaryotic communities from a mesocosm experiment (see Materials and Methods for details), we wanted to test how different choices for assembly software and ORF caller, as well as read depth normalization influences the results. We ran nf-core/metatdenovo with six different parameter settings (Table MST-1-PARAMS). The initial steps of the pipeline -- quality checks, trimming, filtering out rRNAs -- were uniform across all downstream processing steps. After this, we ran read depth normalization to provide input reads for both RNASpades and Megahit. In addition, assembly with Megahit was performed with and without read depth normalization to compare the influence of this procedure, while RNASpades was only run after normalization.

Our analysis shows how different the time and resource consumption of the different steps in the nf-core/metatdenovo pipeline can be based on a different combination of parameters. Quantification emerges as the most time-intensive process, closely followed by quality control (QC), open reading frame (ORF) calling, and assembly (Fig. @fig-extraces A).The option to normalize read coverage stands out as a strategy to optimize resource utilization. Leveraging BBNorm to reduce kmer coverage before assembly demonstrates a reduction in both running time and memory usage, addressing computational demand (Fig. @fig-extraces B). Read-depth normalization exhibits minimal impact on assembly and quantification steps. It influences ORF calling programs, leading to a reduction in resource consumption (numbers). BBnorm not only decreases running time but also proves to be memory-efficient, nearly halving memory usage compared to non-normalized options (@tbl-assembly-stats). The global efficiency gained by incorporating BBnorm across various combinations ranges from ?% to ?%, reflecting an enhancement in workflow performance. Comparing assembly outputs from RNASpades and Megahit reveals nuanced trade-offs. RNASpades generates larger but more fragmented assemblies but a higher proportion of reads mapping back to it. However, normalized assemblies do not attract proportionally fewer reads.

See (@fig-extraces & @tbl-assembly-stats).

```{r fig-extraces}
#| label: fig-extraces
#| fig-height: 5
#| fig-cap: '**CPU consumption, assembly memory usage and size.** A) Realtime cpu use per task type and pipeline execution, B) peak virtual memory usage and C) assembly size per assembly.'

p0 <- extraces %>%
  filter(project == 'mst-1', minlen == 0) %>%
  left_join(process_groups, by = join_by(process)) %>%
  group_by(process_group, run) %>%
  summarise(realtimec = sum(realtimec), .groups = 'drop') %>%
  ggplot(aes(x = run, y = realtimec, fill = process_group)) +
  geom_col() +
  scale_fill_brewer('Process group', palette = 'Paired') +
  xlab('') + ylab('Seconds') +
  coord_flip() +
  theme(axis.text.y = element_text(size=12))

p1 <- extraces %>%
  filter(project == 'mst-1', minlen == 0) %>%
  left_join(process_groups, by = join_by(process)) %>%
  filter(process_group == 'assembly') %>%
  group_by(run) %>%
  filter(peak_vmemc == max(peak_vmemc)) %>%
  ungroup() %>%
  transmute(assembler, bbnorm, peak_vmemc = round(peak_vmemc/1024^3)) %>%
  distinct() %>%
  ggplot(aes(x = assembler, y = peak_vmemc, colour = bbnorm)) +
  geom_point() +
  scale_colour_discrete('') +
  xlab('') +
  ylab('Max. virtual memory (GB)') +
  coord_flip() +
  theme(axis.text.y = element_text(size=12))

p2 <- transrates %>%
  filter(project == 'mst-1', minlen == 0) %>%
  mutate(mbp = n_bases/1000^2 %>% round()) %>%
  ggplot(aes(x = assembler, y = mbp, colour = bbnorm)) +
  geom_point() +
  scale_colour_discrete('') +
  xlab('') +
  ylab('Assembly size (Mbp)') +
  coord_flip() +
  theme(axis.text.y = element_text(size=12))

p0 / ( p1 + p2 ) +
  plot_layout(heights = c(4, 1), guides = 'collect') +
  plot_annotation(tag_levels = 'A')
```

```{r tbl-assembly-stats}
#| label: tbl-assembly-stats
#| tbl-cap: '**Overall statistics for MST-1 assemblies.** *) The assembly was made from read-normalized data. †) Contigs shorter than 200 nucleotides were removed.'

transrates %>%
  filter(project == 'mst-1') %>%
  inner_join(
    overall_stats %>% 
      transmute(project, assembler, bbnorm, minlen, sample, prop_mapped = idxs_n_mapped/n_non_contaminated) %>%
      distinct() %>%
      group_by(project, assembler, bbnorm, minlen) %>%
      summarise(mean_prop_mapped = mean(prop_mapped), .groups = 'drop'),
    by = join_by(project, assembler, bbnorm, minlen)
  ) %>%
  transmute(
    Assembly = assembly,
    `N. contigs` = n_seqs, `Size (Mbp)` = round(n_bases/1000^2, digits = 1),
    `Lengths` = sprintf("%d-%d", smallest, largest), `Mean length (bp)` = round(mean_len), N50 = n50,
    `Mean prop. mapped` = sprintf("%2.1f%%", mean_prop_mapped * 100)
  ) %>%
  arrange(Assembly) %>%
  kable()
```

### ORF calling and annotation

Prokka (REF), one of the two options to identify open reading frames (ORFs) in prokaryotes available in the workflow actually uses the other option, Prodigal (REF), to call ORFs but then proceeds with identification of other types of features and functional annotation. Prokka is generally more conservative with what it considers an ORF, although nf-core/metatdenovo by default uses the --metagenome parameter that is recommended for fragmented genomes and transcriptomes. As expected, Prokka returns much fewer ORFsthan Prodigal (NN Prokka ORFs and NN Prodigal ORFs in the Megahit assembly, and NN and NN respectively in the RNASpades assembly), although the proportion of reads NN% and NN% respectively in the RNASpades assembly). The combination RNAspades-Prodigal demonstrates its capability in identifying shorter, less common, and typically more elusive ORFs (Fig @fig-orf-calling A). This attribute can be particularly advantageous for projects with a focus on uncovering rare or concise ORFs, which might potentially be overlooked by Prokka's criteria. However, it is essential to acknowledge that Prodigal's less stringent approach could also introduce the risk of detecting false positive ORFs. This concern arises from the challenge of distinguishing genuine ORFs from potential artifacts. Consequently, for the majority of projects, Prokka's more conservative methodology proves more beneficial due to its precision and decreased susceptibility to false positives. Interestingly, these particular ORFs detected by Prodigal accumulate a total of NN reads, constituting a mere NN% of all the reads assigned to ORFs. We can speculate that those ORFs might be contaminants or viruses or even an artifact. 
Read-depth normalization in general produces assemblies which after ORF calling have a much narrower count distribution. For instance, considering the Megahit assembly, Prodigal identifies approximately NN ORFs with a length shorter than NN amino acids, while Prokka doesn't identify any such ORFs. 
We proceeded with the comparison by examining the counts of mapped reads obtained from different featureCounts outputs (Fig.@fig-orf-calling B). The combination of RNAspades and Prodigal outperformed the other combinations, achieving NN of mapped reads for all samples except for NA2, where the numbers were NN, a possible sign of contamination. 

See (@fig-orf-calling).

-   The RNASpades assemblies generally have a longer tail of rare ORFs, particularly for the non-read-depth-normalized assembly
-   Read-depth normalization in general produces assemblies which after ORF calling have a much narrower count distribution
-   The difference between the two assembly programs is much stronger when ORFs are called with Prodigal rather than Prokka
-   Whereas most rare ORFs -- occurring in few samples -- have very low counts, a few rare ORFs, have very large counts -- contaminants or viruses?
-   The Prokka ORF caller in combination with read-depth normalization exhibit similar count distributions for both assembly programs
-   Counts much higher for NA2 with Prodigal than with Prokka, particularly for the RNASpades assembly: contamination?

```{r fig-orf-calling}
#| label: fig-orf-calling
#| fig-height: 10
#| fig-cap: '**ORF calling statistics.** A) Rank-abundance curves per ORF with number of samples each ORF occurs in in colour. B) Counts per sample. *) The assembly was made from read-depth-normalized data. †) Contigs shorter than 200 nucleotides were removed before ORF calling.'

plot_rank_abundance <- function(ds) {
  ds %>%
    ggplot(aes(x = cr, y = count, colour = n_samples)) +
    geom_point() +
    scale_colour_viridis_c('N. samples') +
    scale_y_log10() +
    geom_hline(yintercept = 1e1, linetype = 2) +
    xlab('') +
    ylab('N. mapped read pairs') +
    facet_grid(assembly ~ orf_caller) +
    theme(
      legend.position = 'bottom',
      axis.text.x = element_blank(),
      axis.ticks.x = element_blank()
    )
}

p0 <- counts %>%
  filter(project == 'mst-1') %>%
  group_by(run, assembly, assembler, orf_caller, bbnorm, orf) %>%
  summarise(count = sum(count), tpm = sum(tpm), n_samples = n(), .groups = 'drop_last') %>%
  mutate(cr = rank(desc(count), ties.method = 'first'), tpmr = rank(desc(tpm), ties.method = 'first')) %>%
  ungroup() %>%
  plot_rank_abundance()

p1 <- counts %>%
  filter(project == 'mst-1') %>%
  mutate(assembly_orfc = sprintf("%s %s", assembly, orf_caller)) %>%
  group_by(assembly_orfc, sample) %>%
  summarise(count = sum(count), tpm = sum(tpm), n_samples = n(), .groups = 'drop') %>%
  ggplot(aes(x = sample, y = count, fill = sample)) +
  geom_col() +
  scale_colour_brewer('Sample', palette = 'Paired') +
  xlab('') +
  facet_wrap(~assembly_orfc, ncol = 2) +
  theme(
    legend.position = 'bottom',
    axis.text.x = element_blank(),
    axis.ticks.x = element_blank()
  )

p2 <- counts %>%
  filter(project == 'mst-1', minlen == 0) %>%
  select(project:minlen, orf, length) %>% 
  mutate(length = length * 3) %>%
  distinct() %>%
  ggplot(aes(x = assembly, y = length, fill = orf_caller)) +
  geom_violin() +
  scale_y_log10() +
  coord_flip()

( p0 + p1 ) / p2 +
  plot_layout(widths = c(3, 2), heights = c(7,2)) +
  plot_annotation(tag_levels = 'A')
```

-   Large proportions of ORFs annotated at species level, particularly when weighted by count
-   Tendency that ORFs annotated at higher ranks are rarer than species-assigned ORFs.
- Why are mean tpms so low with Prodigal? Could it be explained by rare ORFs,
in particular singletons from NA2?

```{r fig-na2-rank-abundance}
#| label: fig-na2-rank-abundance
#| include: false

# I made this as an experiment to see if this was the way of showing what's going on in NA2, but it doesn't
# work so well.
counts %>%
  filter(project == 'mst-1', sample == 'NA2') %>%
  group_by(run, assembly, assembler, orf_caller, bbnorm, orf) %>%
  summarise(count = sum(count), tpm = sum(tpm), .groups = 'drop_last') %>%
  mutate(cr = rank(desc(count), ties.method = 'first'), tpmr = rank(desc(tpm), ties.method = 'first')) %>%
  ungroup() %>%
  inner_join(
    counts %>%
      filter(project == 'mst-1') %>%
      count(run, orf, name = 'n_samples'),
    by = join_by(run, orf)
  ) %>%
  plot_rank_abundance()
```

### What's the matter with NA2?

* Extreme abundances for contigs and ORFs
* Not seen in any other sample

```{r fig-top-abundances}
#| label: fig-top-abundances
#| fig-cap: '**Ten most abundant A) contigs and B) ORFs per assembly and ORF caller.**'
#| fig-height: 10

p0 <- idxstats %>%
  filter(project == 'mst-1') %>%
  group_by(project, run, assembly, assembler, bbnorm, minlen, contig) %>%
  summarise(max_tpm = max(tpm), .groups = 'drop_last') %>%
  slice_max(n = 10, order_by = max_tpm) %>%
  ungroup() %>%
  inner_join(idxstats %>% select(project, run, contig, sample, tpm), by = join_by(project, run, contig)) %>%
  ggplot(aes(x = contig, y = tpm, fill = sample)) +
  geom_col() +
  coord_flip() +
  facet_wrap(~assembly, scale = 'free_y', ncol = 6) +
  xlab('') +
  scale_y_continuous(limits = c(0, 5e5), breaks = seq(2.5e5, 2.5e5, 2.5e5), labels = scales::scientific) +
  theme(
    axis.text.y  = element_blank(),
    axis.ticks.y = element_blank()
  )
  
p1 <- counts %>%
  filter(project == 'mst-1') %>%
  group_by(project, run, assembly, assembler, orf_caller, bbnorm, minlen, orf) %>%
  summarise(max_tpm = max(tpm), .groups = 'drop_last') %>%
  slice_max(n = 10, order_by = max_tpm) %>%
  ungroup() %>%
  inner_join(counts %>% select(project, run, orf, sample, tpm), by = join_by(project, run, orf)) %>%
  mutate(assembly_orfc = sprintf("%s %s", assembly, orf_caller)) %>%
  ggplot(aes(x = orf, y = tpm, fill = sample)) +
  geom_col() +
  coord_flip() +
  facet_wrap(~assembly_orfc, ncol = 2, scale = 'free_y') +
  theme(
    axis.text.y  = element_blank(),
    axis.ticks.y = element_blank()
  )

p0 / p1 +
  plot_layout(heights = c(1,4), guides = 'collect') +
  plot_annotation(tag_levels = 'A')
```

```{r fig-mst-1-annot-success}
#| label: fig-mst-1-annot-success
#| fig.height: 6
#| fig-cap: '**Annotation success.** A) GTDB taxonomy and B) combinations of functional annotation. Unweighted, weighted by count and tpm respectively.'

p0 <- eukulele %>%
  filter(project == 'mst-1', db == 'gtdb') %>%
  inner_join(
    counts %>%
      group_by(project, run, assembler, orf_caller, bbnorm, minlen, orf) %>%
      summarise(count = sum(count), tpm = sum(tpm), .groups = 'drop'),
    by = join_by(project, run, assembler, orf_caller, bbnorm, minlen, orf)
  ) %>%
  group_by(run, assembly, assembler, orf_caller, bbnorm, minlen, taxon_rank) %>%
  summarise(`N. ORFs` = n(), count = sum(count), tpm = sum(tpm), .groups = 'drop') %>%
  pivot_longer(`N. ORFs`:tpm, names_to = 'var', values_to = 'value') %>%
  mutate(var = factor(var, levels = c('N. ORFs', 'count', 'tpm'), ordered = TRUE)) %>%
  ggplot(aes(run, value, fill = taxon_rank)) +
  geom_col() +
  scale_fill_brewer('Rank', palette = 'Set1') +
  facet_wrap(~var, scales = 'free_x') +
  xlab('') + ylab('') +
  coord_flip() +
  theme(
    axis.text.x = element_text(angle = 65, hjust = 1)
  )

p1 <- func_annots %>%
  filter(project == 'mst-1') %>%
  inner_join(
    counts %>%
      group_by(project, run, assembler, orf_caller, bbnorm, minlen, orf) %>%
      summarise(count = sum(count), tpm = sum(tpm), .groups = 'drop'),
    by = join_by(project, run, assembler, orf_caller, bbnorm, minlen, orf)
  ) %>%
  group_by(run, assembly, assembler, orf_caller, bbnorm, minlen, combination) %>%
  summarise(`N. ORFs` = n(), count = sum(count), tpm = sum(tpm), .groups = 'drop') %>%
  pivot_longer(`N. ORFs`:tpm, names_to = 'var', values_to = 'value') %>%
  mutate(var = factor(var, levels = c('N. ORFs', 'count', 'tpm'), ordered = TRUE)) %>%
  ggplot(aes(run, value, fill = combination)) +
  geom_col() +
  scale_fill_brewer('Annotation tools', palette = 'Set2') +
  facet_wrap(~var, scales = 'free_x') +
  xlab('') + ylab('') +
  coord_flip() +
  theme(
    axis.text.x = element_text(angle = 65, hjust = 1)
  )

p0 / p1 +
  plot_annotation(tag_levels = 'A')
```

# Discussion

# References
