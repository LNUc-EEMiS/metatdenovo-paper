---
title: "nf-core/metatdenovo"
author: "danilo.dileo@lnu.se, emelie.nilsson@lnu.se, ..., daniel.lundin@lnu.se"
date: "`r format(Sys.time(), '%Y-%m-%d')`"
format:
  html:
    code-fold: true
    toc: true
bibliography:
  - bibliography.bib
  - grateful-refs.bib
---

```{r setup}
#| label: setup
#| echo: false
#| cache: false

knitr::opts_chunk$set(echo = TRUE, fig.path='figures/', cache = TRUE, fig.width = 10)
ggplot2::theme_set(ggplot2::theme_bw())
```

```{r libraries}
#| label: libraries
#| message: false
#| cache: false
#| include: false

library(readr)
library(data.table)
library(dtplyr)
library(dplyr, warn.conflicts = FALSE)
library(tidyr)
library(lubridate)
library(purrr)
library(stringr)
library(ggplot2)
library(kfigr)
library(knitr)
library(DT)
library(grateful)
library(patchwork)
```

```{r constants}
#| label: constants
```

```{r read-execution-traces}
#| label: read-data
extraces <- Sys.glob('nextflow/*/*/pipeline_info/execution_trace*') %>%
  read_tsv(show_col_types = FALSE, id = 'fname') %>%
  mutate(
    project = str_replace(fname, 'nextflow\\/([^/]+)\\/.*', '\\1'),
    run     = str_remove(fname, 'nextflow\\/[^/]+\\/') %>% str_remove('\\/.*'),
    p       = str_remove(name, '.*:'),
    process = str_remove(p, ' .*'),
    sample  = str_replace(p, '.*\\((.*)\\)', '\\1'),
    durationc  = str_remove(duration, ' *\\d+ms') %>%
      ifelse(str_detect(., '\\dh'), ., str_c('0h', ., sep = ' ')) %>%
      ifelse(str_detect(., '\\dm'), ., str_c('0m', ., sep = ' ')) %>%
      ifelse(str_detect(., '\\ds'), ., str_c(., '0s', sep = ' ')) %>%
      hms(),
    realtimec  = str_remove(realtime, ' *\\d+ms') %>%
      ifelse(str_detect(., '\\dh'), ., str_c('0h', ., sep = ' ')) %>%
      ifelse(str_detect(., '\\dm'), ., str_c('0m', ., sep = ' ')) %>%
      ifelse(str_detect(., '\\ds'), ., str_c(., '0s', sep = ' ')) %>%
      hms(),
    peak_rssc = case_when(
      str_detect(peak_rss, 'GB') ~ str_remove(peak_rss, ' .*') %>% as.numeric() * 1024^3,
      str_detect(peak_rss, 'MB') ~ str_remove(peak_rss, ' .*') %>% as.numeric() * 1024^2,
      str_detect(peak_rss, 'KB') ~ str_remove(peak_rss, ' .*') %>% as.numeric() * 1024^1,
      str_detect(peak_rss, 'B')  ~ str_remove(peak_rss, ' .*') %>% as.numeric() * 1024^0,
      TRUE                       ~ 0
    ),
    peak_vmemc = case_when(
      str_detect(peak_vmem, 'GB') ~ str_remove(peak_rss, ' .*') %>% as.numeric() * 1024^3,
      str_detect(peak_vmem, 'MB') ~ str_remove(peak_rss, ' .*') %>% as.numeric() * 1024^2,
      str_detect(peak_vmem, 'KB') ~ str_remove(peak_rss, ' .*') %>% as.numeric() * 1024^1,
      str_detect(peak_vmem, 'B')  ~ str_remove(peak_rss, ' .*') %>% as.numeric() * 1024^0,
      TRUE                       ~ 0
    ),
    rcharc = case_when(
      str_detect(rchar, 'GB') ~ str_remove(peak_rss, ' .*') %>% as.numeric() * 1024^3,
      str_detect(rchar, 'MB') ~ str_remove(peak_rss, ' .*') %>% as.numeric() * 1024^2,
      str_detect(rchar, 'KB') ~ str_remove(peak_rss, ' .*') %>% as.numeric() * 1024^1,
      str_detect(rchar, 'B')  ~ str_remove(peak_rss, ' .*') %>% as.numeric() * 1024^0,
      TRUE                       ~ 0
    ),
    wcharc = case_when(
      str_detect(wchar, 'GB') ~ str_remove(peak_rss, ' .*') %>% as.numeric() * 1024^3,
      str_detect(wchar, 'MB') ~ str_remove(peak_rss, ' .*') %>% as.numeric() * 1024^2,
      str_detect(wchar, 'KB') ~ str_remove(peak_rss, ' .*') %>% as.numeric() * 1024^1,
      str_detect(wchar, 'B')  ~ str_remove(peak_rss, ' .*') %>% as.numeric() * 1024^0,
      TRUE                       ~ 0
    )
  ) %>%
  select(-p, -fname) %>%
  separate(run, c('assembler', 'orf_caller', 'bbnorm', 'minlen'), remove = FALSE, sep = '\\.', fill = 'right') %>%
  mutate(minlen = ifelse(is.na(minlen), 0, str_remove(minlen, 'minlen') %>% as.integer())) %>%
  relocate(project, run, assembler, orf_caller, bbnorm, minlen, process, sample)

process_groups <- read_tsv('data/process_groups.tsv', show_col_types = FALSE)
```

```{r read-overall-stats}
#| label: read-overall-stats
#| warning: false
overall_stats <- Sys.glob('nextflow/*/*/summary_tables/*overall_stats.tsv.gz') %>%
  read_tsv(id = 'fname', show_col_types = FALSE) %>%
  mutate(
    project = str_replace(fname, 'nextflow\\/([^/]+)\\/.*', '\\1'),
    run     = str_remove(fname, 'nextflow\\/[^/]+\\/') %>% str_remove('\\/.*')
  ) %>%
  select(-fname) %>%
  separate(run, c('assembler', 'orf_caller', 'bbnorm', 'minlen'), remove = FALSE, sep = '\\.', fill = 'right') %>%
  mutate(minlen = ifelse(is.na(minlen), 0, str_remove(minlen, 'minlen') %>% as.integer())) %>%
  relocate(project, run, assembler, orf_caller, bbnorm, minlen)
```

```{r read-transrate}
#| label: read-transrate
#| warning: false
transrates <- Sys.glob('nextflow/*/*/transrate/*.csv') %>%
  read_csv(id = 'fname', show_col_types = FALSE) %>%
  mutate(
    project = str_replace(fname, 'nextflow\\/([^/]+)\\/.*', '\\1'),
    run     = str_remove(fname, 'nextflow\\/[^/]+\\/') %>% str_remove('\\/.*')
  ) %>%
  separate(run, c('assembler', 'orf_caller', 'bbnorm', 'minlen'), remove = FALSE, sep = '\\.', fill = 'right') %>%
  select(-fname, -run, -orf_caller) %>%
  mutate(minlen = ifelse(is.na(minlen), 0, str_remove(minlen, 'minlen') %>% as.integer())) %>%
  relocate(project, assembler, bbnorm, minlen) %>%
  distinct()
```

```{r read-counts}
#| label: read-counts

counts <- Sys.glob('nextflow/*/*/summary_tables/*.counts.tsv.gz') %>%
  read_tsv(id = 'fname', show_col_types = FALSE) %>%
  mutate(
    project = str_replace(fname, 'nextflow\\/([^/]+)\\/.*', '\\1'),
    run     = str_remove(fname, 'nextflow\\/[^/]+\\/') %>% str_remove('\\/.*')
  ) %>%
  select(-fname) %>%
  separate(run, c('assembler', 'orf_caller', 'bbnorm', 'minlen'), remove = FALSE, sep = '\\.', fill = 'right') %>%
  mutate(minlen = ifelse(is.na(minlen), 0, str_remove(minlen, 'minlen') %>% as.integer())) %>%
  relocate(project, run, assembler, orf_caller, bbnorm, minlen, sample)
```

# Version history

# Summary

# Introduction

Cite nf-core [@nf-core].

# Materials and Methods

## R and packages

This analysis was run with `r R.version$version.string`. Versions of packages used can be found in Table @tbl-cite-packages.

```{r}
#| label: tbl-cite-packages
#| cache: false
#| tbl-cap: Versions of R and packages used in this analysis.

cite_packages(output = "table", pkgs = "Session", out.dir = getwd()) %>%
  kable()
```

# Results

## MST-1

### Resource usage and assembly quality with different parameter values

* Quantification takes longest followed by QC, ORF calling and assembly
* Read-depth normalization with BBDuk does not reduce time for assembly but considerably decrease memory usage
* RNASpades created larger, but more fragmented assemblies than Megahit
* The larger assemblies, the higher the proportion of reads mapping back to the assembly
* The assemblies created with normalization did not attract proportionally lower proportions of reads -> normalization not such a bad idea! :-)

See (**@fig-extraces** & **@tbl-assembly-stats**).

```{r fig-extraces}
#| label: fig-extraces
#| fig-height: 5
#| fig-cap: '**CPU consumption, assembly memory usage and size.** A) Realtime cpu use per task type and pipeline execution, B) peak virtual memory usage and C) assembly size per assembly.'

p0 <- extraces %>%
  filter(project == 'mst-1') %>%
  left_join(process_groups, by = join_by(process)) %>%
  group_by(process_group, run) %>%
  summarise(realtimec = sum(realtimec), .groups = 'drop') %>%
  ggplot(aes(x = run, y = realtimec, fill = process_group)) +
  geom_col() +
  scale_fill_brewer('Process group', palette = 'Paired') +
  xlab('') + ylab('Seconds') +
  coord_flip() +
  theme(axis.text.y = element_text(size=12))

p1 <- extraces %>%
  filter(project == 'mst-1') %>%
  left_join(process_groups, by = join_by(process)) %>%
  filter(process_group == 'assembly') %>%
  group_by(run) %>%
  filter(peak_vmemc == max(peak_vmemc)) %>%
  ungroup() %>%
  transmute(assembler, bbnorm, peak_vmemc = round(peak_vmemc/1024^3)) %>%
  distinct() %>%
  ggplot(aes(x = assembler, y = peak_vmemc, colour = bbnorm)) +
  geom_point() +
  scale_colour_discrete('') +
  xlab('') +
  ylab('Max. virtual memory (GB)') +
  coord_flip() +
  theme(axis.text.y = element_text(size=12))

p2 <- transrates %>%
  filter(project == 'mst-1') %>%
  mutate(mbp = n_bases/1000^2 %>% round()) %>%
  ggplot(aes(x = assembler, y = mbp, colour = bbnorm)) +
  geom_point() +
  scale_colour_discrete('') +
  xlab('') +
  ylab('Assembly size (Mbp)') +
  coord_flip() +
  theme(axis.text.y = element_text(size=12))

p0 / ( p1 + p2 ) +
  plot_layout(heights = c(4, 1), guides = 'collect') +
  plot_annotation(tag_levels = 'A')
```

```{r tbl-assembly-stats}
#| label: tbl-assembly-stats
#| tbl-cap: '**Overall statistics for MST-1 assemblies.**'

transrates %>%
  filter(project == 'mst-1') %>%
  inner_join(
    overall_stats %>% 
      transmute(project, assembler, bbnorm, sample, prop_mapped = idxs_n_mapped/n_non_contaminated) %>%
      distinct() %>%
      group_by(project, assembler, bbnorm) %>%
      summarise(mean_prop_mapped = mean(prop_mapped), .groups = 'drop'),
    by = join_by(project, assembler, bbnorm)
  ) %>%
  transmute(
    Assembly = str_c(assembler, bbnorm, sep = '.'),
    `N. contigs` = n_seqs, `Size (Mbp)` = round(n_bases/1000^2, digits = 1),
    `Lengths` = sprintf("%d-%d", smallest, largest), `Mean length (bp)` = round(mean_len), N50 = n50,
    `Mean prop. mapped` = sprintf("%2.1f%%", mean_prop_mapped * 100)
  ) %>%
  kable()
```


### ORF calling and annotation

See (**@fig-orf-calling**).

* The RNASpades assemblies generally have a longer tail of rare ORFs, particularly for the non-read-depth-normalized assembly
* Read-depth normalization in general produces assemblies which after ORF calling have a much narrower count distribution
* The difference between the two assembly programs is much stronger when ORFs are called with Prodigal rather than Prokka
* Whereas most rare ORFs -- occurring in few samples -- have very low counts, a few rare ORFs, have very large counts -- contaminants or viruses?
* The Prokka ORF caller in combination with read-depth normalization exhibit similar count distributions for both assembly programs
* Counts much higher for NA2 with Prodigal than with Prokka, particularly for the RNASpades assembly: contamination?

```{r fig-orf-calling}
#| label: fig-orf-calling
#| fig-cap: '**ORF calling statistics.** A) Rank-abundance curves per ORF with number of samples each ORF occurs in in colour. B) Counts per sample.'

p0 <- counts %>%
  filter(project == 'mst-1') %>%
  group_by(run, assembler, orf_caller, bbnorm, orf) %>%
  summarise(count = sum(count), tpm = sum(tpm), n_samples = n(), .groups = 'drop_last') %>%
  mutate(cr = rank(desc(count), ties.method = 'first'), tpmr = rank(desc(tpm), ties.method = 'first')) %>%
  ungroup() %>%
  mutate(assembler_norm = sprintf("%s%s", assembler, ifelse(bbnorm == 'with_bbnorm', '*', ''))) %>%
  ggplot(aes(x = cr, y = count, colour = n_samples)) +
  geom_point() +
  scale_colour_viridis_c('N. samples') +
  scale_y_log10() +
  geom_hline(yintercept = 1e1, linetype = 2) +
  xlab('') +
  ylab('N. mapped read pairs') +
  facet_grid(assembler_norm ~ orf_caller) +
  theme(legend.position = 'bottom')

p1 <- counts %>%
  filter(project == 'mst-1') %>%
  mutate(assembly_orfc = sprintf("%s%s %s", assembler, ifelse(bbnorm == 'with_bbnorm', '*', ''), orf_caller)) %>%
  group_by(assembly_orfc, sample) %>%
  summarise(count = sum(count), tpm = sum(tpm), n_samples = n(), .groups = 'drop') %>%
  ggplot(aes(x = sample, y = count, fill = sample)) +
  geom_col() +
  scale_colour_brewer('Sample', palette = 'Paired') +
  xlab('') +
  facet_wrap(~assembly_orfc, ncol = 2) +
  theme(
    legend.position = 'bottom',
    axis.text.x = element_blank(),
    axis.ticks.x = element_blank()
  )

p0 + p1 +
  plot_layout(widths = c(3, 2)) +
  plot_annotation(tag_levels = 'A')
```


# Discussion

# References
