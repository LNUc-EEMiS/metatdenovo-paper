---
title: "nf-core/metatdenovo"
author: "danilo.dileo@lnu.se, emelie.nilsson@lnu.se, ..., daniel.lundin@lnu.se"
date: "`r format(Sys.time(), '%Y-%m-%d')`"
format:
  html:
    code-fold: true
    toc: true
  pdf:
    toc: true
    number-sections: true
    colorlinks: true
bibliography:
  - bibliography.bib
  - grateful-refs.bib
---

```{r setup}
#| label: setup
#| echo: false
#| cache: false

knitr::opts_chunk$set(echo = TRUE, fig.path='figures/', cache = TRUE, fig.width = 10)
ggplot2::theme_set(ggplot2::theme_bw())
```

```{r libraries}
#| label: libraries
#| message: false
#| cache: false
#| include: false

library(readr)
library(forcats)
library(tibble)
library(dplyr, warn.conflicts = FALSE)
library(tidyr)
library(lubridate)
library(purrr)
library(stringr)
library(ggplot2)
library(kfigr)
library(knitr)
library(DT)
library(grateful)
library(patchwork)
```

```{r constants}
#| label: constants

TAXON_RANKS_SORTED = c('root', 'domain', 'phylum', 'class', 'order', 'family', 'genus', 'species')
mst1.samples.color <- c("#ea3a25", "#f09536", "#1a43f5", "#74fafd")
```

```{r func-post-process-table}
#| label: func-post-process-table
post_process_table <- function(paths) {
  #t <- Sys.glob('nextflow/*/*/summary_tables/*.gtdb-r220.diamond.taxonomy.tsv.gz') %>%
  #t <- Sys.glob('nextflow/*/*/summary_tables/*.counts.tsv.gz') %>%
  paths %>%
    read_tsv(id = 'fname', show_col_types = FALSE) %>%
    mutate(
      project = str_replace(fname, 'nextflow\\/([^/]+)\\/.*', '\\1'),
      run     = str_remove(fname, 'nextflow\\/[^/]+\\/') %>% str_remove('\\/.*')
    ) %>%
    separate(run, c('assembler', 'orf_caller', 'bbnorm', 'minlen'), remove = FALSE, sep = '\\.', fill = 'right') %>%
    mutate(
      minlen = case_when(
        is.na(minlen)                 ~ 0,
        str_detect(minlen, 'diamond') ~ 0, 
        str_detect(minlen, 'minlen')  ~ str_remove(minlen, 'minlen') %>% as.integer()
      )
    ) %>%
    mutate(
      assembly = sprintf("%s%s%s%s", 
        assembler, 
        ifelse(!is.na(bbnorm) & bbnorm == 'with_bbnorm', '*', ''), 
        ifelse(!is.na(minlen) & minlen > 0, '†', ''), 
        ifelse(str_detect(fname, 'top3'), '3', '')
      )
    ) %>%
    relocate(project, run, assembly, assembler, orf_caller, bbnorm, minlen)
}
```

```{r create-samples}
#| label: create-samples

samples <- tribble(
  ~sample, ~treatment, ~replicate,
  'KA1',   'control_acidified', '1',
  'KA2',   'control_acidified', '2',
  'KB1',   'control_nonacidified', '1',
  'KB2',   'control_nonacidified', '2',
  'NA1',   'nutrients_acidified', '1',
  'NA2',   'nutrients_acidified', '2',
  'NB1',   'nutrients_nonacidified', '1',
  'NB2',   'nutrients_nonacidified', '2' 
)
```

```{r read-execution-traces}
#| label: read-data
#| cache-lazy: false

extraces <- Sys.glob('nextflow/*/*/pipeline_info/execution_trace*') %>%
  str_subset('top3', negate = TRUE) %>%
  read_tsv(col_types = 'icicccTccccccc', id = 'fname') %>%
  mutate(
    project = str_replace(fname, 'nextflow\\/([^/]+)\\/.*', '\\1'),
    run     = str_remove(fname, 'nextflow\\/[^/]+\\/') %>% str_remove('\\/.*'),
    p       = str_remove(name, '.*:'),
    process = str_remove(p, ' .*'),
    sample  = str_replace(p, '.*\\((.*)\\)', '\\1'),
    durationc  = str_remove(duration, ' *\\d+ms') %>%
      ifelse(str_detect(., '\\dh'), ., str_c('0h', ., sep = ' ')) %>%
      ifelse(str_detect(., '\\dm'), ., str_c('0m', ., sep = ' ')) %>%
      ifelse(str_detect(., '\\ds'), ., str_c(., '0s', sep = ' ')) %>%
      hms(),
    realtimec  = str_remove(realtime, ' *\\d+ms') %>%
      ifelse(str_detect(., '\\dh'), ., str_c('0h', ., sep = ' ')) %>%
      ifelse(str_detect(., '\\dm'), ., str_c('0m', ., sep = ' ')) %>%
      ifelse(str_detect(., '\\ds'), ., str_c(., '0s', sep = ' ')) %>%
      hms(),
    num_cpus   = ( str_remove(`%cpu`, '%') %>%
      as.double()/100 ) %>%
      ceiling(),
    peak_rssc = case_when(
      str_detect(peak_rss, 'GB') ~ str_remove(peak_rss, ' .*') %>% as.numeric() * 1024^3,
      str_detect(peak_rss, 'MB') ~ str_remove(peak_rss, ' .*') %>% as.numeric() * 1024^2,
      str_detect(peak_rss, 'KB') ~ str_remove(peak_rss, ' .*') %>% as.numeric() * 1024^1,
      str_detect(peak_rss, 'B')  ~ str_remove(peak_rss, ' .*') %>% as.numeric() * 1024^0,
      TRUE                       ~ 0
    ),
    peak_vmemc = case_when(
      str_detect(peak_vmem, 'GB') ~ str_remove(peak_rss, ' .*') %>% as.numeric() * 1024^3,
      str_detect(peak_vmem, 'MB') ~ str_remove(peak_rss, ' .*') %>% as.numeric() * 1024^2,
      str_detect(peak_vmem, 'KB') ~ str_remove(peak_rss, ' .*') %>% as.numeric() * 1024^1,
      str_detect(peak_vmem, 'B')  ~ str_remove(peak_rss, ' .*') %>% as.numeric() * 1024^0,
      TRUE                       ~ 0
    ),
    rcharc = case_when(
      str_detect(rchar, 'GB') ~ str_remove(peak_rss, ' .*') %>% as.numeric() * 1024^3,
      str_detect(rchar, 'MB') ~ str_remove(peak_rss, ' .*') %>% as.numeric() * 1024^2,
      str_detect(rchar, 'KB') ~ str_remove(peak_rss, ' .*') %>% as.numeric() * 1024^1,
      str_detect(rchar, 'B')  ~ str_remove(peak_rss, ' .*') %>% as.numeric() * 1024^0,
      TRUE                       ~ 0
    ),
    wcharc = case_when(
      str_detect(wchar, 'GB') ~ str_remove(peak_rss, ' .*') %>% as.numeric() * 1024^3,
      str_detect(wchar, 'MB') ~ str_remove(peak_rss, ' .*') %>% as.numeric() * 1024^2,
      str_detect(wchar, 'KB') ~ str_remove(peak_rss, ' .*') %>% as.numeric() * 1024^1,
      str_detect(wchar, 'B')  ~ str_remove(peak_rss, ' .*') %>% as.numeric() * 1024^0,
      TRUE                       ~ 0
    )
  ) %>%
  select(-p, -fname) %>%
  separate(run, c('assembler', 'orf_caller', 'bbnorm', 'minlen'), remove = FALSE, sep = '\\.', fill = 'right') %>%
  mutate(minlen = ifelse(is.na(minlen), 0, str_remove(minlen, 'minlen') %>% as.integer())) %>%
  mutate(assembly = sprintf("%s%s%s", assembler, ifelse(bbnorm == 'with_bbnorm', '*', ''), ifelse(minlen > 0, '†', ''))) %>%
  relocate(project, run, assembly, assembler, orf_caller, bbnorm, minlen, process, sample)
```

```{r read-process-groups}
#| label: read-process-groups

process_groups <- read_tsv('data/process_groups.tsv', show_col_types = FALSE) %>%
  mutate(process_group = factor(process_group) %>% fct_reorder(as.numeric(ordernum)) %>% fct_rev())
```

```{r read-overall-stats}
#| label: read-overall-stats
#| warning: false
#| cache-lazy: false

overall_stats <- Sys.glob('nextflow/*/*/summary_tables/*overall_stats.tsv.gz') %>%
  str_subset('top3', negate = TRUE) %>%
  read_tsv(id = 'fname', show_col_types = FALSE) %>%
  mutate(
    project = str_replace(fname, 'nextflow\\/([^/]+)\\/.*', '\\1'),
    run     = str_remove(fname, 'nextflow\\/[^/]+\\/') %>% str_remove('\\/.*')
  ) %>%
  select(-fname) %>%
  separate(run, c('assembler', 'orf_caller', 'bbnorm', 'minlen'), remove = FALSE, sep = '\\.', fill = 'right') %>%
  mutate(minlen = ifelse(is.na(minlen), 0, str_remove(minlen, 'minlen') %>% as.integer())) %>%
  mutate(assembly = sprintf("%s%s%s", assembler, ifelse(bbnorm == 'with_bbnorm', '*', ''), ifelse(minlen > 0, '†', ''))) %>%
  relocate(project, run, assembly, assembler, orf_caller, bbnorm, minlen)
```

```{r read-transrates}
#| label: read-transrates
#| warning: false
#| cache-lazy: false

transrates <- Sys.glob('nextflow/*/*/transrate/*.csv') %>%
  str_subset('top3', negate = TRUE) %>%
  str_subset('prodigal') %>%
  read_csv(id = 'fname', show_col_types = FALSE) %>%
  mutate(
    project = str_replace(fname, 'nextflow\\/([^/]+)\\/.*', '\\1'),
    run     = str_remove(fname, 'nextflow\\/[^/]+\\/') %>% str_remove('\\/.*')
  ) %>%
  separate(run, c('assembler', 'orf_caller', 'bbnorm', 'minlen'), remove = FALSE, sep = '\\.', fill = 'right') %>%
  select(-fname, -run, -orf_caller) %>%
  mutate(minlen = ifelse(is.na(minlen), 0, str_remove(minlen, 'minlen') %>% as.integer())) %>%
  mutate(assembly = sprintf("%s%s%s", assembler, ifelse(bbnorm == 'with_bbnorm', '*', ''), ifelse(minlen > 0, '†', ''))) %>%
  relocate(project, assembly, assembler, bbnorm, minlen) %>%
  distinct()
```

```{r read-idxstats}
#| label: read-idxstats
#| cache-lazy: false

idxstats <- Sys.glob('nextflow/*/*/samtools/*.idxstats') %>%
  str_subset('top3', negate = TRUE) %>%
  #post_process_table()
  read_tsv(id = 'fname', show_col_types = FALSE, col_names = c('contig', 'length', 'n_mapped', 'n_unmapped')) %>%
  filter(contig != '*', n_mapped > 0) %>%
  mutate(
    project = str_replace(fname, 'nextflow\\/([^/]+)\\/.*', '\\1'),
    run     = str_remove(fname,  'nextflow\\/[^/]+\\/') %>% str_remove('\\/.*') %>% str_replace('^([^.]+)\\.[^.]+(.*)', '\\1\\2'),
    sample  = str_replace(fname, '.*\\.([^.]+).idxstats', '\\1')
  ) %>%
  select(-fname) %>%
  distinct() %>%
  mutate(r = n_mapped/length) %>%
  group_by(project, run, sample) %>%
  mutate(tpm = r/sum(r) * 1e6) %>%
  ungroup() %>%
  select(-r) %>%
  separate(run, c('assembler', 'bbnorm', 'minlen'), remove = FALSE, sep = '\\.', fill = 'right') %>%
  mutate(minlen = ifelse(is.na(minlen), 0, str_remove(minlen, 'minlen') %>% as.integer())) %>%
  mutate(assembly = sprintf("%s%s%s", assembler, ifelse(bbnorm == 'with_bbnorm', '*', ''), ifelse(minlen > 0, '†', ''))) %>%
  relocate(project, run, assembly, assembler, bbnorm, minlen, sample)
```

```{r read-counts}
#| label: read-counts
#| cache-lazy: false

counts <- Sys.glob('nextflow/*/*/summary_tables/*.counts.tsv.gz') %>%
  #str_subset('top3', negate = TRUE) %>%
  post_process_table()
```

```{r read-eukulele}
#| label: read-eukulele
#| cache-lazy: false

eukulele <- Sys.glob('nextflow/*/*/summary_tables/*eukulele.taxonomy.tsv.gz') %>%
  str_subset('top3', negate = TRUE) %>%
  post_process_table() %>%
  mutate(
    db      = str_replace(fname, 'nextflow\\/.*\\.(.*).eukulele.taxonomy.tsv.gz', '\\1'),
  ) %>%
  select(-fname) %>%
  mutate(
    taxon_rank = case_when(
      str_detect(domain,  'uncl\\.')  ~ 'root',
      str_detect(phylum,  'uncl\\.')  ~ 'domain',
      str_detect(class,   'uncl\\.')  ~ 'phylum',
      str_detect(order,   'uncl\\.')  ~ 'class',
      str_detect(family,  'uncl\\.')  ~ 'order',
      str_detect(genus,   'uncl\\.')  ~ 'family',
      str_detect(species, 'uncl\\.')  ~ 'genus',
      TRUE                            ~ 'species'
    ) %>% factor(levels = TAXON_RANKS_SORTED, ordered = TRUE)
  )
```

```{r read-diamondtax}
#| label: read-diamondtax
diamondtax.gtdb <- Sys.glob('nextflow/*/*/summary_tables/*.gtdb-r220.diamond.taxonomy.tsv.gz') %>%
  #str_subset('top3', negate = TRUE) %>%
  post_process_table() %>%
  mutate(
    taxon_rank = case_when(
      is.na(domain)  ~ 'root',
      is.na(phylum)  ~ 'domain',
      is.na(class)   ~ 'phylum',
      is.na(order)   ~ 'class',
      is.na(family)  ~ 'order',
      is.na(genus)   ~ 'family',
      is.na(species) ~ 'genus',
      TRUE           ~ 'species'
    ) %>% factor(levels = TAXON_RANKS_SORTED, ordered = TRUE)
  ) %>%
  select(-fname)
diamondtax.refseq <- Sys.glob('nextflow/*/*/summary_tables/*.ncbi-refseq-*.diamond.taxonomy.tsv.gz') %>%
  #str_subset('top3', negate = TRUE) %>%
  post_process_table() %>%
  select(-fname)
```

```{r read-eggnogs}
#| label: read-eggnogs
#| cache-lazy: false

eggnogs <- Sys.glob('nextflow/*/*/summary_tables/*.emapper.tsv.gz') %>%
  str_subset('top3', negate = TRUE) %>%
  read_tsv(id = 'fname', show_col_types = FALSE) %>%
  mutate(
    project = str_replace(fname, 'nextflow\\/([^/]+)\\/.*', '\\1'),
    run     = str_remove(fname, 'nextflow\\/[^/]+\\/') %>% str_remove('\\/.*')
  ) %>%
  select(-fname) %>%
  separate(run, c('assembler', 'orf_caller', 'bbnorm', 'minlen'), remove = FALSE, sep = '\\.', fill = 'right') %>%
  mutate(minlen = ifelse(is.na(minlen), 0, str_remove(minlen, 'minlen') %>% as.integer())) %>%
  mutate(assembly = sprintf("%s%s%s", assembler, ifelse(bbnorm == 'with_bbnorm', '*', ''), ifelse(minlen > 0, '†', ''))) %>%
  rename_with(str_to_lower) %>%
  relocate(project, run, assembly, assembler, orf_caller, bbnorm, minlen)

eggnogs.edger <- read_tsv(
  'nextflow/mst-1/megahit.prokka.without_bbnorm/summary_tables/megahit.prokka.emapper.tsv.gz',
  show_col_types = FALSE
) %>%
  rename_all(str_to_lower) %>%
  select(orf, eggnog_ogs, cog_category, description, preferred_name) %>%
  separate_rows(eggnog_ogs, sep = ',') %>%
  separate(eggnog_ogs, c('eggnog', 'taxon'), sep = '@') %>%
  # Some ORFs have duplicate annotations for a taxon
  group_by(orf, taxon) %>%
  arrange(eggnog) %>%
  filter(row_number() == 1) %>%
  ungroup()
```

```{r read-kofams}
#| label: read-kofams
#| cache-lazy: false

kofams <- Sys.glob('nextflow/*/*/summary_tables/*.kofamscan.tsv.gz') %>%
  str_subset('top3', negate = TRUE) %>%
  read_tsv(id = 'fname', show_col_types = FALSE) %>%
  mutate(
    project = str_replace(fname, 'nextflow\\/([^/]+)\\/.*', '\\1'),
    run     = str_remove(fname, 'nextflow\\/[^/]+\\/') %>% str_remove('\\/.*')
  ) %>%
  select(-fname) %>%
  separate(run, c('assembler', 'orf_caller', 'bbnorm', 'minlen'), remove = FALSE, sep = '\\.', fill = 'right') %>%
  mutate(minlen = ifelse(is.na(minlen), 0, str_remove(minlen, 'minlen') %>% as.integer())) %>%
  mutate(assembly = sprintf("%s%s%s", assembler, ifelse(bbnorm == 'with_bbnorm', '*', ''), ifelse(minlen > 0, '†', ''))) %>%
  relocate(project, run, assembly, assembler, orf_caller, bbnorm, minlen)
```

```{r read-prokkas}
#| label: read-prokkas
#| cache-lazy: false

prokkas <- Sys.glob('nextflow/*/*/summary_tables/*.prokka-annotations.tsv.gz') %>%
  str_subset('top3', negate = TRUE) %>%
  read_tsv(id = 'fname', show_col_types = FALSE, guess_max = 1e6) %>%
  mutate(
    project = str_replace(fname, 'nextflow\\/([^/]+)\\/.*', '\\1'),
    run     = str_remove(fname, 'nextflow\\/[^/]+\\/') %>% str_remove('\\/.*')
  ) %>%
  select(-fname) %>%
  separate(run, c('assembler', 'orf_caller', 'bbnorm', 'minlen'), remove = FALSE, sep = '\\.', fill = 'right') %>%
  mutate(minlen = ifelse(is.na(minlen), 0, str_remove(minlen, 'minlen') %>% as.integer())) %>%
  mutate(assembly = sprintf("%s%s%s", assembler, ifelse(bbnorm == 'with_bbnorm', '*', ''), ifelse(minlen > 0, '†', ''))) %>%
  relocate(project, run, assembly, assembler, orf_caller, bbnorm, minlen)
```

```{r read-edger-output}
#| label: read-edger-output
#| cache-lazy: false

# the analysis is made out the run megahit.prokka_without_normalization
edger <- read_tsv('tables/mst-1_megahit.prokka.without_bbnorm.edger.tsv.gz', show_col_types = FALSE, guess_max = 1e6)
```

```{r func-annots}
#| label: func-annots
#| cache-lazy: false

func_annots <- eggnogs %>% select(project:minlen, orf) %>% mutate(orf, annot = 'eggnog') %>% distinct() %>%
  union(
    kofams %>% select(project:minlen, orf) %>% mutate(orf, annot = 'kofam') %>% distinct()
  ) %>%
  union(
    prokkas %>% filter(product != 'hypothetical protein') %>% 
      select(project:minlen, orf) %>% mutate(orf, annot = 'prokka') %>% distinct()
  ) %>%
  pivot_wider(names_from = annot, values_from = annot) %>%
  unite(combination, c(eggnog, kofam, prokka), sep = '+', na.rm = TRUE)
```

```{r hellinger-pcas}
#| label: hellinger-pcas
#| eval: false
# hellinger_pca <- function(ds) {
#   ds %>%
#     group_by(sample, variable) %>%
#     summarise(count = sum(count), .groups = 'drop') %>%
#     pivot_wider(names_from = variable, values_from = count, values_fill = 0) %>%
#     as.data.frame() %>%
#     column_to_rownames('sample') %>%
#     vegan::decostand(method = 'hellinger') %>%
#     vegan::rda()
# }
# pcas <- list()
# for ( r in counts %>% distinct(run) %>% filter(str_detect(run, 'without_bbnorm')) %>% pull(run) ) {
#   pcas[[sprintf("%s-eggnogs", r)]] <- counts %>% 
#     filter(run == r) %>%
#     inner_join(
#       eggnogs %>%
#         select(project, run, eggnog_ogs, orf) %>%
#         separate_rows(eggnog_ogs, sep = ',') %>%
#         separate(eggnog_ogs, c('eggnog', 'taxon'), sep = '@') %>%
#         filter(taxon == '1|root') %>%
#         select(-taxon) %>%
#         distinct(run, orf, .keep_all = TRUE),
#       by = join_by(project, run, orf)
#     ) %>%
#     rename(variable = eggnog) %>%
#     hellinger_pca()
#   pcas[[sprintf("%s-families", r)]] <- counts %>% 
#     filter(run == r) %>% 
#     inner_join(
#       eukulele %>%
#         select(project, run, orf, domain:species),
#       by = join_by(project, run, orf)
#     ) %>%
#     rename(variable = family) %>%
#     hellinger_pca()
# }
```

```{r tax-annots-og}
#| label: tax-annots-og
#| cache-lazy: false

# DL: It would be better to have this and the next one in tables that we read in.
original.tax <- tibble(
  sample = c(rep("Lca",7), rep("Lcc",7), rep("Hca",7), rep("Hcc",7)),
  family = c(rep(c("Other Flavobacteria", "Flavobacteriaceae", "Other Gammaproteobacteria", "Alteromonadaceae", "Other Alphaproteobacteria", "SAR11 clade", "Rhodobacteraceae"),4)),
  tpm = c(0.1, 0.5, 2.3, 2.4, 0.3, 0.4, 0.1,
          0.1, 0.5, 2.3, 2.3, 0.5, 0.2, 0.1,
          0.3, 0.5, 2.5, 0.7, 0.4, 0.1, 0.1,
          0.1, 0.7, 2.5, 1.7, 0.9, 0.2, 0.2)
  )
```

```{r func-annots-og}
#| label: func-annots-og
#| cache-lazy: false

original.fun <- tibble(
  sample = c(rep("Lca",13), rep("Lcc",13), rep("Hca",13), rep("Hcc",13)),
  SEED = c(rep(c("Protein metabolism", "Clustering-based subsystem", "RNA Metabolism", "Membrane Transport", "Carbohydrates", "Miscellaneous", "Amino Acids and Derivates", "Respiration", "Cofactors, vitamins, Pigments", "Iron acquisition and mtabolism", "Nucleosiles and Nucleotides", "Fatty Acids", "Photosynthesis"),4)),
  tpm = c(2.9, 1.8, 0.9, 1.1, 0.8, 0.88, 0.70, 0.88, 0.5, 0.5, 0.3, 0.15, 0.35,
          3.3, 2, 1, 1, 0.82, 0.89, 0.72, 0.72, 0.52, 0.48, 0.33, 0.17, 0.3,
          2.9, 2.4, 0.85, 0.85, 0.96, 0.78, 0.80, 0.70, 0.57, 0.45, 0.4, 0.25, 0.15,
          3.1, 2.2, 0.88, 0.88, 0.97, 0.88, 0.78, 0.77, 0.56, 0.46, 0.35, 0.3, 0.2))
```

# Version history

# Summary

# Introduction

Cite nf-core [@nf-core].

# Materials and Methods

Compute resources were taken from Nextflow's `execution_trace*` files after making sure that the pipeline finished in a single run.
To calculate the cpu time, the `realtimec` column was multiplied with the number of cpus.
The latter was calculated by rounding the `%cpu` up to the nearest hundred and dividing by a hundred.

## R and packages

This analysis was run with `r R.version$version.string`. Versions of packages used can be found in Table @tbl-cite-packages.

```{r tbl-cite-packages}
#| label: tbl-cite-packages
#| cache: false
#| tbl-cap: Versions of R and packages used in this analysis.

cite_packages(output = "table", pkgs = "Session", out.dir = getwd()) %>%
  kable()
```

# Results

## MST-1

### Resource usage and assembly quality with different parameter values

See (@fig-extraces & @tbl-assembly-stats).

* Main difference in time taken is the ORF-caller: Prokka is much slower
* Assembly time not very different between Megahit 
(mean: `r extraces %>% filter(process == 'MEGAHIT_INTERLEAVED') %>% summarise(m = mean(realtimec * num_cpus)) %>% pull(m)` seconds)
and RNASpades
(mean: `r extraces %>% filter(process == 'SPADES') %>% summarise(m = mean(realtimec * num_cpus)) %>% pull(m)` seconds).
* Memory consumption for RNASpades ~4 times higher than for Megahit.
* Assembly size at least twice larger for RNASpades than for Megahit.
* The proportion mapping back does not differ as much, suggesting that many of the extra contigs from RNASpades are rare.

```{r fig-extraces}
#| label: fig-extraces
#| fig-height: 5
#| fig-cap: '**CPU consumption, assembly memory usage and size.** A) Realtime cpu use per task type and pipeline execution, B) peak virtual memory usage and C) assembly size per assembly. Cpu use was calculated by the product of wall time and number of cpus used.'

p0 <- extraces %>%
  filter(project == 'mst-1') %>% #, minlen == 0) %>%
  left_join(process_groups, by = join_by(process)) %>%
  arrange(assembly, bbnorm, orf_caller) %>%
  mutate(name = sprintf("%s: %s", assembly, orf_caller) %>% factor() %>% fct_inorder() %>% fct_rev()) %>%
  group_by(process_group, name) %>%
  summarise(realtimec = sum(realtimec * num_cpus), .groups = 'drop') %>%
  ggplot(aes(x = name, y = realtimec, fill = process_group)) +
  geom_col() +
  scale_fill_brewer('Process group', palette = 'Paired') +
  xlab('') + ylab('Seconds') +
  coord_flip() +
  theme(axis.text.y = element_text(size=12))

p1 <- extraces %>%
  filter(project == 'mst-1') %>% #, minlen == 0) %>%
  left_join(process_groups, by = join_by(process)) %>%
  filter(process_group == 'assembly') %>%
  mutate(assembler = factor(assembler) %>% fct_inorder() %>% fct_rev()) %>%
  group_by(run) %>%
  filter(peak_vmemc == max(peak_vmemc)) %>%
  ungroup() %>%
  transmute(assembler, bbnorm, peak_vmemc = round(peak_vmemc/1024^3)) %>%
  distinct() %>%
  ggplot(aes(x = assembler, y = peak_vmemc, colour = bbnorm)) +
  geom_point() +
  scale_colour_discrete('') +
  xlab('') +
  ylab('Max. virtual memory (GB)') +
  ylim(0, 30) +
  coord_flip() +
  theme(axis.text.y = element_text(size=12))

p2 <- transrates %>%
  filter(project == 'mst-1') %>% #, minlen == 0) %>%
  mutate(mbp = n_bases/1000^2 %>% round()) %>%
  mutate(assembler = factor(assembler) %>% fct_inorder() %>% fct_rev()) %>%
  ggplot(aes(x = assembler, y = mbp, colour = bbnorm)) +
  geom_point() +
  scale_colour_discrete('') +
  xlab('') +
  ylab('Assembly size (Mbp)') +
  ylim(0, 200) +
  coord_flip() +
  theme(axis.text.y = element_text(size=12))

p0 / ( p1 + p2 ) +
  plot_layout(heights = c(4, 1), guides = 'collect') +
  plot_annotation(tag_levels = 'A')
```

```{r tbl-extraces}
#| label: tbl-extraces
#| tbl-cap: '**Resource usage per manuscript category.**'
process_groups %>% 
  inner_join(extraces, by = join_by(process)) %>%
  group_by(assembly, orf_caller, manuscript_group) %>% 
  summarise(realtimec = sum(realtimec * num_cpus), max_memory_gb = round(max(peak_vmemc)/1024^3), .groups = 'drop') %>% 
  group_by(assembly, orf_caller) %>% 
  mutate(realtimeprop = round(realtimec/sum(realtimec), 2)) %>% 
  ungroup() %>%
  kable()
```

```{r tbl-assembly-stats}
#| label: tbl-assembly-stats
#| tbl-cap: '**Overall statistics for MST-1 assemblies.** The runs using the Prodigal ORF caller was used for this table. *) The assembly was made from read-normalized data. †) Contigs shorter than 200 nucleotides were removed using the --min_contig_length parameter.'

transrates %>%
  filter(project == 'mst-1') %>%
  filter(! ( assembler == 'spades' & minlen == 0) ) %>%
  inner_join(
    overall_stats %>% 
      transmute(project, assembler, bbnorm, minlen, sample, prop_mapped = idxs_n_mapped/n_non_contaminated) %>%
      distinct() %>%
      group_by(project, assembler, bbnorm, minlen) %>%
      summarise(mean_prop_mapped = mean(prop_mapped), .groups = 'drop'),
    by = join_by(project, assembler, bbnorm, minlen)
  ) %>%
  arrange(assembler, bbnorm) %>%
  transmute(
    Assembly = assembly,
    `N. contigs` = n_seqs, `Size (Mbp)` = round(n_bases/1000^2, digits = 1),
    `Lengths` = sprintf("%d-%d", smallest, largest), `Mean length (bp)` = round(mean_len), N50 = n50,
    `Mean prop. mapped` = sprintf("%2.1f%%", mean_prop_mapped * 100)
  ) %>%
  kable()
```

### ORF calling and annotation

See (@fig-orf-calling).

-   The RNASpades assemblies generally have a longer tail of rare ORFs, particularly for the non-read-depth-normalized assembly
-   Read-depth normalization in general produces assemblies which after ORF calling have a much narrower count distribution
-   The difference between the two assembly programs is much stronger when ORFs are called with Prodigal rather than Prokka
-   Whereas most rare ORFs -- occurring in few samples -- have very low counts, a few rare ORFs, have very large counts -- contaminants or viruses?
-   The Prokka ORF caller in combination with read-depth normalization exhibit similar count distributions for both assembly programs
-   Counts much higher for NA2 with Prodigal than with Prokka, particularly for the RNASpades assembly: contamination?

```{r fig-orf-calling}
#| label: fig-orf-calling
#| fig-height: 8
#| fig-cap: '**ORF calling statistics.** A) Rank-abundance curves per ORF with number of samples each ORF occurs in in colour. B) Counts per sample. C) Length distributions of ORFs for the four assemblies using Prodigal or Prokka. *) The assembly was made from read-depth-normalized data. †) Contigs shorter than 200 nucleotides were removed before ORF calling.'

plot_rank_abundance <- function(ds) {
  ds %>%
    ggplot(aes(x = cr, y = count, colour = n_samples)) +
    geom_point() +
    scale_colour_viridis_c('N. samples') +
    scale_y_log10() +
    geom_hline(yintercept = 1e1, linetype = 2) +
    xlab('') +
    ylab('N. mapped read pairs') +
    facet_grid(assembly ~ orf_caller) +
    theme(
      legend.position = 'bottom',
      axis.text.x = element_blank(),
      axis.ticks.x = element_blank()
    )
}

p0 <- counts %>%
  filter(project == 'mst-1') %>%
  filter(! ( assembler == 'spades' & minlen == 0) ) %>%
  filter(assembly != 'megahit3') %>%
  group_by(run, assembly, assembler, orf_caller, bbnorm, orf) %>%
  summarise(count = sum(count), tpm = sum(tpm), n_samples = n(), .groups = 'drop_last') %>%
  arrange(assembler, bbnorm) %>%
  mutate(assembly = factor(assembly) %>% fct_inorder() %>% fct_rev()) %>%
  mutate(cr = rank(desc(count), ties.method = 'first'), tpmr = rank(desc(tpm), ties.method = 'first')) %>%
  ungroup() %>%
  plot_rank_abundance()

p1 <- counts %>%
  filter(project == 'mst-1') %>%
  filter(! ( assembler == 'spades' & minlen == 0) ) %>%
  filter(assembly != 'megahit3') %>%
  arrange(assembly, bbnorm, orf_caller) %>%
  mutate(assembly_orfc = sprintf("%s: %s", assembly, orf_caller) %>% factor() %>% fct_inorder()) %>%
  group_by(assembly_orfc, assembler, orf_caller, bbnorm, assembly, sample) %>%
  summarise(count = sum(count), tpm = sum(tpm), n_samples = n(), .groups = 'drop') %>%
  inner_join(overall_stats, by = join_by(assembler, orf_caller, bbnorm, assembly, sample)) %>%
  mutate(prop_mapped_to_orfs = count/n_non_contaminated) %>%
  ggplot(aes(x = sample, y = prop_mapped_to_orfs * 100, fill = sample)) +
  geom_col() +
  scale_colour_brewer('Sample', palette = 'Paired') +
  xlab('') +
  ylab('% read pairs mapped to ORFs') +
  facet_wrap(~assembly_orfc, ncol = 2) +
  theme(
    legend.position = 'bottom',
    axis.text.x = element_blank(),
    axis.ticks.x = element_blank()
  )

p2 <- counts %>%
  filter(project == 'mst-1') %>%
  filter(! ( assembler == 'spades' & minlen == 0) ) %>%
  filter(assembly != 'megahit3') %>%
  select(project:minlen, orf, length) %>% 
  mutate(length = length * 3) %>%
  distinct() %>%
  arrange(assembler, bbnorm) %>%
  mutate(assembly = factor(assembly) %>% fct_inorder() %>% fct_rev()) %>%
  ggplot(aes(x = assembly, y = length, fill = orf_caller)) +
  geom_violin(draw_quantiles = c(0.5)) +
  scale_y_log10() +
  scale_fill_discrete('ORF caller') +
  xlab('') +
  coord_flip()

( p0 + p1 ) / p2 +
  plot_layout(widths = c(3, 2), heights = c(7,4)) +
  plot_annotation(tag_levels = 'A')
```

-   Large proportions of ORFs annotated at species level, particularly when weighted by count
-   Tendency that ORFs annotated at higher ranks are rarer than species-assigned ORFs.
-   Why are mean tpms so low with Prodigal? Could it be explained by rare ORFs, in particular singletons from NA2?

```{r fig-mst-1-annot-success}
#| label: fig-mst-1-annot-success
#| fig.height: 8
#| fig-cap: '**Annotation success.** A) GTDB taxonomy and B) combinations of functional annotation. Unweighted, weighted by count and tpm respectively.'

p0 <- eukulele %>%
  filter(project == 'mst-1', db == 'gtdb') %>%
  select(project, run, assembler, orf_caller, bbnorm, minlen, orf, assembly, taxon_rank) %>%
  mutate(tool = 'EUKulele') %>%
  union(
    diamondtax.gtdb %>%
      filter(taxon_rank != 'root') %>%
      select(project, run, assembler, orf_caller, bbnorm, minlen, orf, assembly, taxon_rank) %>%
      mutate(tool = 'Diamond-tax')
  ) %>%
  anti_join(
    diamondtax.refseq %>% filter(str_detect(taxonomy, 'Eukaryota') | str_detect(taxonomy, 'Viruses')),
    by = join_by(project, run, assembler, orf_caller, bbnorm, minlen, orf, assembly)
  ) %>%
  #filter(! ( assembler == 'spades' & minlen == 0) ) %>%
  inner_join(
    counts %>%
      group_by(project, run, assembler, orf_caller, bbnorm, minlen, orf) %>%
      summarise(count = sum(count), tpm = sum(tpm), .groups = 'drop'),
    by = join_by(project, run, assembler, orf_caller, bbnorm, minlen, orf)
  ) %>%
  group_by(run, assembly, assembler, orf_caller, bbnorm, minlen, taxon_rank, tool) %>%
  summarise(`N. ORFs` = n(), count = sum(count), tpm = sum(tpm), .groups = 'drop') %>%
  pivot_longer(`N. ORFs`:tpm, names_to = 'var', values_to = 'value') %>%
  mutate(var = factor(var, levels = c('N. ORFs', 'count', 'tpm'), ordered = TRUE)) %>%
  mutate(name = sprintf("%s: %s", assembly, orf_caller)) %>%
  arrange(assembler, bbnorm, orf_caller) %>%
  mutate(name = factor(name) %>% fct_inorder() %>% fct_rev()) %>%
  ggplot(aes(name, value, fill = taxon_rank)) +
  geom_col() +
  scale_fill_brewer('Rank', palette = 'Set1') +
  facet_wrap(tool~var, scales = 'free') +
  xlab('') + ylab('') +
  coord_flip() +
  theme(
    axis.text.x = element_text(angle = 65, hjust = 1)
  )

p1 <- func_annots %>%
  filter(project == 'mst-1') %>%
  #filter(! ( assembler == 'spades' & minlen == 0) ) %>%
  inner_join(
    counts %>%
      group_by(project, run, assembler, orf_caller, bbnorm, minlen, orf) %>%
      summarise(count = sum(count), tpm = sum(tpm), .groups = 'drop'),
    by = join_by(project, run, assembler, orf_caller, bbnorm, minlen, orf)
  ) %>%
  group_by(run, assembly, assembler, orf_caller, bbnorm, minlen, combination) %>%
  summarise(`N. ORFs` = n(), count = sum(count), tpm = sum(tpm), .groups = 'drop') %>%
  pivot_longer(`N. ORFs`:tpm, names_to = 'var', values_to = 'value') %>%
  mutate(var = factor(var, levels = c('N. ORFs', 'count', 'tpm'), ordered = TRUE)) %>%
  mutate(name = sprintf("%s: %s", assembly, orf_caller)) %>%
  arrange(assembler, bbnorm, orf_caller) %>%
  mutate(name = factor(name) %>% fct_inorder() %>% fct_rev()) %>%
  ggplot(aes(name, value, fill = combination)) +
  geom_col() +
  scale_fill_brewer('Annotation tools', palette = 'Set2') +
  facet_wrap(~ var, scales = 'free') +
  xlab('') + ylab('') +
  coord_flip() +
  theme(
    axis.text.x = element_text(angle = 65, hjust = 1)
  )


p0 / p1 +
  plot_annotation(tag_levels = 'A') +
  plot_layout(heights = c(2.8,1))
```

### What's the matter with NA2?

* Extreme abundances for contigs and ORFs
* Not seen in any other sample

* Some of the long, abundant contigs from *Staphylococcus cohnii* and *S. haemolyticus* -- unlikely marine bacteria

```{r fig-na2-rank-abundance}
#| label: fig-na2-rank-abundance
#| include: false

# I made this as an experiment to see if this was the way of showing what's going on in NA2, but it doesn't
# work so well.
counts %>%
  filter(project == 'mst-1', sample == 'NA2') %>%
  group_by(run, assembly, assembler, orf_caller, bbnorm, orf) %>%
  summarise(count = sum(count), tpm = sum(tpm), .groups = 'drop_last') %>%
  mutate(cr = rank(desc(count), ties.method = 'first'), tpmr = rank(desc(tpm), ties.method = 'first')) %>%
  ungroup() %>%
  inner_join(
    counts %>%
      filter(project == 'mst-1') %>%
      count(run, orf, name = 'n_samples'),
    by = join_by(run, orf)
  ) %>%
  plot_rank_abundance()
```

```{r fig-top-abundances}
#| label: fig-top-abundances
#| fig-cap: '**Ten most abundant A) contigs and B) ORFs per assembly and ORF caller.**'
#| fig-height: 10

p0 <- idxstats %>%
  filter(project == 'mst-1') %>%
  group_by(project, run, assembly, assembler, bbnorm, minlen, contig) %>%
  summarise(max_tpm = max(tpm), .groups = 'drop_last') %>%
  slice_max(n = 10, order_by = max_tpm) %>%
  ungroup() %>%
  inner_join(idxstats %>% select(project, run, contig, sample, tpm), by = join_by(project, run, contig)) %>%
  ggplot(aes(x = contig, y = tpm, fill = sample)) +
  geom_col() +
  coord_flip() +
  facet_wrap(~assembly, scale = 'free_y', ncol = 6) +
  xlab('') +
  scale_y_continuous(limits = c(0, 5e5), breaks = seq(2.5e5, 2.5e5, 2.5e5), labels = scales::scientific) +
  theme(
    axis.text.y  = element_blank(),
    axis.ticks.y = element_blank()
  )
  
p1 <- counts %>%
  filter(project == 'mst-1') %>%
  group_by(project, run, assembly, assembler, orf_caller, bbnorm, minlen, orf) %>%
  summarise(max_tpm = max(tpm), .groups = 'drop_last') %>%
  slice_max(n = 10, order_by = max_tpm) %>%
  ungroup() %>%
  inner_join(counts %>% select(project, run, orf, sample, tpm), by = join_by(project, run, orf)) %>%
  mutate(assembly_orfc = sprintf("%s %s", assembly, orf_caller)) %>%
  ggplot(aes(x = orf, y = tpm, fill = sample)) +
  geom_col() +
  coord_flip() +
  facet_wrap(~assembly_orfc, ncol = 2, scale = 'free_y') +
  theme(
    axis.text.y  = element_blank(),
    axis.ticks.y = element_blank()
  )

p0 / p1 +
  plot_layout(heights = c(1,4), guides = 'collect') +
  plot_annotation(tag_levels = 'A')
```

### Functional and taxonomic annotation - comparison with original data

```{r fig-mst-1-family-pcas}
#| label: fig-mst-1-family-pcas
#| fig-cap: '**MST-1 PCAs based on data summed at family.**'
#| include: false

# plot_pca <- function(pca, t) {
#   e <- pca$eig
#   
#   pca$u %>%
#     as.data.frame() %>%
#     rownames_to_column('sample') %>%
#     inner_join(samples, by = join_by(sample)) %>%
#     ggplot(aes(x = PC1, y = PC2, colour = treatment, shape = replicate)) +
#     geom_point() +
#     #scale_colour_brewer('Sample', palette = 'Paired') +
#     xlab(sprintf("PC1 (%2.1f%%)", pca$eig[['PC1']]/sum(pca$eig) * 100)) +
#     ylab(sprintf("PC2 (%2.1f%%)", pca$eig[['PC2']]/sum(pca$eig) * 100)) +
#     ggtitle(t)
# }
# 
# p0 <- pcas[['megahit.prokka.without_bbnorm-families']][['CA']] %>% plot_pca('MEGAHIT/Prokka')
# p1 <- pcas[['megahit.prodigal.without_bbnorm-families']][['CA']] %>% plot_pca('MEGAHIT/Prodigal')
# p2 <- pcas[['spades.prokka.without_bbnorm-families']][['CA']] %>% plot_pca('RNASpades/Prokka')
# p3 <- pcas[['spades.prodigal.without_bbnorm-families']][['CA']] %>% plot_pca('RNASpades/Prodigal')
# 
# ( p0 + p1 ) /
#   ( p2 + p3 ) +
#   plot_layout(guides = 'collect')
```

```{r mst-1-eggnog-pcas}
#| label: mst-1-eggnog-pcas
#| fig-cap: '**MST-1 PCAs based on data summed at the root EGGNOG.**'
#| include: false

# p0 <- pcas[['megahit.prokka.without_bbnorm-eggnogs']][['CA']] %>% plot_pca('MEGAHIT/Prokka')
# p1 <- pcas[['megahit.prodigal.without_bbnorm-eggnogs']][['CA']] %>% plot_pca('MEGAHIT/Prodigal')
# p2 <- pcas[['spades.prokka.without_bbnorm-eggnogs']][['CA']] %>% plot_pca('RNASpades/Prokka')
# p3 <- pcas[['spades.prodigal.without_bbnorm-eggnogs']][['CA']] %>% plot_pca('RNASpades/Prodigal')
# 
# ( p0 + p1 ) /
#   ( p2 + p3 ) +
#   plot_layout(guides = 'collect')
```

### Functional annotation - comparison with original data

```{r fig-mst-1-func-annot-comparison}
#| label: fig-mst-1-func-annot-comparison
#| fig.height: 6
#| fig-cap: '**Annotation comparison** A) Eggnogs COG category and B) SEED category from original paper.'
#| cache-lazy: false

# it makes easier to compare one type of run with the original function annotation.
# we can have as supplementary figures a plot with all the combination.
# here I will plot megahit.prokka.without_bbnorm vs original paper

# Classification by COG category
counts.eggnogs <- counts %>%
  mutate(sample = if_else(grepl("KA1", sample), 'Lca', sample)) %>%
  mutate(sample = if_else(grepl("KA2", sample), 'Lca', sample)) %>%
  mutate(sample = if_else(grepl("NA1", sample), 'Hca', sample)) %>%
  mutate(sample = if_else(grepl("NA2", sample), 'Hca', sample)) %>%
  mutate(sample = if_else(grepl("KB1", sample), 'Lcc', sample)) %>%
  mutate(sample = if_else(grepl("KB2", sample), 'Lcc', sample)) %>%
  mutate(sample = if_else(grepl("NB1", sample), 'Hcc', sample)) %>%
  mutate(sample = if_else(grepl("NB2", sample), 'Hcc', sample)) %>%
  group_by(project, run, assembler, orf_caller, bbnorm, minlen, sample, orf) %>%
  summarise(m_tpm = mean(tpm),
            sd = sd(tpm),
            .groups = 'drop') %>%
  left_join( eggnogs, by = join_by(project, run, assembler, orf_caller, bbnorm, minlen, orf) ) %>%
  mutate(cog_category = replace(cog_category, cog_category == 'A', 'RNA_process')) %>%
  mutate(cog_category = replace(cog_category, cog_category == 'B', 'Chromatin_Struc')) %>%
  mutate(cog_category = replace(cog_category, cog_category == 'C', 'Energy_prod')) %>%
  mutate(cog_category = replace(cog_category, cog_category == 'D', 'Cell_cycle')) %>%
  mutate(cog_category = replace(cog_category, cog_category == 'E', 'AA_metab')) %>%
  mutate(cog_category = replace(cog_category, cog_category == 'F', 'Nucl_metab')) %>%
  mutate(cog_category = replace(cog_category, cog_category == 'G', 'Carbohy_metab')) %>%
  mutate(cog_category = replace(cog_category, cog_category == 'H', 'Coenz_metab')) %>%
  mutate(cog_category = replace(cog_category, cog_category == 'I', 'Lipid_metab')) %>%
  mutate(cog_category = replace(cog_category, cog_category == 'J', 'Tranlsation')) %>%
  mutate(cog_category = replace(cog_category, cog_category == 'K', 'Transcription')) %>%
  mutate(cog_category = replace(cog_category, cog_category == 'L', 'Replication')) %>%
  mutate(cog_category = replace(cog_category, cog_category == 'M', 'Cell_wall')) %>%
  mutate(cog_category = replace(cog_category, cog_category == 'N', 'Cell_motility')) %>%
  mutate(cog_category = replace(cog_category, cog_category == 'O', 'Post-transl_mod')) %>%
  mutate(cog_category = replace(cog_category, cog_category == 'P', 'Inorg_ion_transp')) %>%
  mutate(cog_category = replace(cog_category, cog_category == 'Q', 'Sec_Structure')) %>%
  mutate(cog_category = replace(cog_category, cog_category == 'T', 'Signal_Transduc')) %>%
  mutate(cog_category = replace(cog_category, cog_category == 'U', 'Intracel_traf')) %>%
  mutate(cog_category = replace(cog_category, cog_category == 'Y', 'Nucl_structure')) %>%
  mutate(cog_category = replace(cog_category, cog_category == 'Z', 'Cytoskeleton')) %>%
  mutate(cog_category = replace(cog_category, cog_category == 'R', 'Gen_Func')) %>%
  mutate(cog_category = replace(cog_category, cog_category == 'S', 'Func_unknown')) %>%
  mutate(cog_category = replace(cog_category, cog_category == '-', 'Func_unknown'))

top13cog <- counts.eggnogs %>%
  #filter( cog_category != '(S)Func_unknown') %>%
  group_by(cog_category, sample) %>%
  summarise(tpm = sum(m_tpm),  .groups = 'drop_last') %>%
  summarise(mean_tpm = mean(tpm), .groups = 'drop') %>%
  slice_max(mean_tpm, n = 13) %>%
  na.omit()

# top 13 expressed COG category divided by samples
p3 <- ( counts.eggnogs %>%
    as_tibble() %>%
    inner_join(top13cog, by = 'cog_category') %>%
    group_by(run, sample, cog_category) %>%
    summarise(tpm = sum(m_tpm)/10^5, .groups = 'drop') %>%
    mutate(cog_category = reorder(cog_category, -tpm)) %>%
    na.omit() %>%
    filter( run == 'megahit.prokka.without_bbnorm') %>%
    ggplot(aes(x = cog_category, y = tpm)) +
    theme(
          legend.position = 'null') +
    scale_fill_manual(values = mst1.samples.color) +
    geom_col(aes(fill = sample), position = 'dodge', colour = 'Black') +
    labs(x = "", y = "TPM(x10^5)") +
    theme(axis.text.x = element_text(angle = 45, hjust = 1, size = 7)) ) +
  ( original.fun %>%
    as_tibble() %>%
    group_by(sample, SEED) %>%
    summarise(tpm = sum(tpm), .groups = 'drop') %>%
    mutate(SEED = reorder(SEED, -tpm)) %>%
    na.omit() %>%
    ggplot(aes(x = SEED, y = tpm)) +
      scale_fill_manual(values = mst1.samples.color) +
      geom_col(aes(fill = sample), position = 'dodge', colour = 'Black') +
      labs(y = "TPM(x10^5)", x = "") +
      theme(axis.text.x = element_text(angle = 45, hjust = 1, size = 7)) )
```

```{r mst spades prodigal - functional annotation table - selected genes, echo = FALSE, warning = FALSE}
# # check the same genes that are DE in MST paper
# # nqrB atpC ccoN nqrE pet (there are severals type), ccmC, sdhd, coxN, mxaF, rhodopsin (change in prd), psaC, psbC, actP, secD, secE, multidrug transport system (change in mtsp), dicarboxylate transport system (change in ttdt), PFAM Sodium sulphate symporter (change in str), dctM (in pfam), nucleoside transporter (change in nucT), pyrophosphate-specific outer membrane porin (change in oprO)

# create the dataframe
# rename those values in the column that are not correct
counts.eggnogs.selectedgenes <- counts.eggnogs %>%
  mutate(preferred_name = recode( preferred_name, "pet.*"= "pet")) %>%
  mutate(preferred_name = if_else(grepl("DctM.*", pfams), "dctM", preferred_name)) %>%
  mutate(preferred_name = if_else(grepl("*Bacteriorhodopsin*", description), "prd", preferred_name)) %>%
  mutate(preferred_name = if_else(grepl("PFAM Sodium sulphate symporter", description), "str", preferred_name)) %>%
  mutate(preferred_name = if_else(grepl("*dicarboxylate transport system*", description), "ttdt", preferred_name)) %>%
  mutate(preferred_name = if_else(grepl("*nucleoside transporter*", description), "nucT", preferred_name)) %>%
  mutate(preferred_name = if_else(grepl("*pyrophosphate-specific outer membrane porin*", description), "oprO", preferred_name)) %>%
  mutate(preferred_name = if_else(grepl("*multidrug transport system*", description), "mtsp", preferred_name)) %>%
  mutate(preferred_name = if_else(grepl("*Zn-dependent protease with chaperone function*", description), "pcf", preferred_name)) %>%
  mutate(preferred_name = if_else(grepl("*PQQ-like domain*", description), "mxaF", preferred_name)) %>%
  mutate(preferred_name = if_else(grepl("*Low-potential electron donor to a number of redox enzymes*", description), "fld", preferred_name)) %>%
  mutate(preferred_name = if_else(grepl("*tail specific protease*", description), "cpt", preferred_name)) %>%
  mutate(preferred_name = if_else(grepl("*Belongs to the peptidase S41A family*", description), "ctp", preferred_name)) %>%
  mutate(preferred_name = if_else(grepl("*Peptidase, S41 family*", description), "ctp", preferred_name)) %>%
  mutate(preferred_name = if_else(grepl("*chemotaxis, protein*", description), "ctp", preferred_name)) %>%
  mutate(preferred_name = if_else(grepl("*rbc*", preferred_name), "rbc", preferred_name)) %>%
  mutate(preferred_name = if_else(grepl("*Molybdopterin oxidoreductase Fe4S4 domain*", description), "mor", preferred_name)) %>%
  mutate(preferred_name = if_else(grepl("*Flagellar regulatory protein FleQ*", description), "fleq", preferred_name)) %>%
  mutate(preferred_name = if_else(grepl("*Haemolysin-type calcium-binding repeat (2 copies)*", description), "hcbr", preferred_name)) %>%
  as_tibble() %>%
  group_by(sample, preferred_name) %>%
  summarise(tpm = sum(m_tpm), .groups = 'drop') %>%
  na.omit() %>%
  filter( sample %in% c("Lca", "Lcc")) %>%
  filter( preferred_name %in% c("atpC", "nqrB", "ccoN", "nqrE", "ccmC", "sdhD", "coxN", "mxaF", "pet", "dctM", "prd", "ttdt", "nucT", "oprO", "mtsp", "pcf", "fld", "ctp", "rbc", "mor", "mraY", "hcbr") )

# create the order for the x-axis as the same as in the original paper
counts.eggnogs.selectedgenes$preferred_name <- factor(counts.eggnogs.selectedgenes$preferred_name, levels = c("nqrB", "atpC", "ccoN", "nqrE", "pet", "ccmC", "sdhD", "coxN", "mxaF", "dctM", "prd", "ttdt", "nucT", "oprO", "mtsp", "pcf", "fld", "ctp", "rbc", "mor", "mraY", "hcbr"))

setcol <- c( "red", "dark green")
# plot the result
p5 <- counts.eggnogs.selectedgenes %>%
  filter( preferred_name != "str") %>%
  ggplot(aes(x = preferred_name, y = tpm, fill = sample )) +
  geom_col(position = "dodge", color = "black") +
  scale_fill_manual(values = setcol) +
  scale_y_log10(limits = c(1, 1e6)) +
  theme(axis.text.x = element_text(angle = 90, hjust = 1, size = 10)) +
  theme(legend.position = 'none') +
  labs(x = "", y = "tpm")
```

```{r fig-edgeR-analysis}
#| label: fig-mst-1-edgerR-analysis
#| warning: false
#| fig.height: 6
#| fig-cap: '**Edger output** A) eggnogs that have differencial expression according to EdgeR output'
#| cache-lazy: false
#| include: false

p6 <- edger %>%
  filter(PValue < 0.01) %>%
  filter(logFC > 1.5) %>%
  filter(contrast == 'KA-KB') %>%
  inner_join((eggnogs.edger %>%
               select(-orf) %>%
               distinct()) %>%
               filter( taxon == '1|root'), by = 'eggnog') %>%
  #filter( cog_category != '-' ) %>%
  #filter(!grepl("^2", eggnog)) %>%
  group_by(eggnog) %>%
  mutate(rank = row_number()) %>%
  ungroup() %>%
  filter( rank == 1) %>%
  inner_join(eggnogs.edger[,c(1,2)], by = 'eggnog' ) %>%
  inner_join(counts %>% filter( sample == 'KA1' | sample == 'KA2' |
                                  sample == 'KB1' | sample == 'KB2'), by = 'orf') %>%
  mutate(sample = if_else(grepl("KA1", sample), 'KA', sample)) %>%
  mutate(sample = if_else(grepl("KA2", sample), 'KA', sample)) %>%
  mutate(sample = if_else(grepl("KB1", sample), 'KB', sample)) %>%
  mutate(sample = if_else(grepl("KB2", sample), 'KB', sample)) %>%
  group_by(sample, eggnog, logFC) %>%
  summarise(m_tpm = mean(tpm), .groups = 'drop') %>%
  ggplot(aes(x=eggnog)) +
  scale_fill_manual(values = setcol) +
  geom_col(aes(y=log(m_tpm), fill = sample),
           position = 'dodge',
           colour = 'Black') +
        geom_point(aes(y=logFC)) +
        theme_minimal() +
  scale_y_continuous(
    name = "log(TPM)",
    sec.axis = sec_axis(~ ., name = "logFC")
  ) +
  theme(axis.text.x = element_text(angle = 90, hjust = 1, size = 6))
```

```{r fig-mst-1-tax-annot-comparison}
#| label: fig-mst-1-tax-annot-comparison
#| warning: false
#| fig.height: 10
#| fig-cap: '**Funcional and taxonomical annotation comparison** A) Eggnogs COG category and B) SEED category from original paper. C) Genes found with nf-core/metatdenovo and original paper. D) eggnogs that have differencial expression according to EdgeR output. E) GTDB database from nf-core/metatdenovo and F) taxonomy from original paper.'
#| cache-lazy: false

# it makes easier to compare one type of run with the original annotation. 
# we can have as supplementary figures a plot with all the combination.
# here I will plot megahit.prokka.without_bbnorm vs original paper

# join taxonomy and counts
counts.tax <- counts %>%
  mutate(sample = if_else(grepl("KA1", sample), 'Lca', sample)) %>%
  mutate(sample = if_else(grepl("KA2", sample), 'Lca', sample)) %>%
  mutate(sample = if_else(grepl("NA1", sample), 'Hca', sample)) %>%
  mutate(sample = if_else(grepl("NA2", sample), 'Hca', sample)) %>%
  mutate(sample = if_else(grepl("KB1", sample), 'Lcc', sample)) %>%
  mutate(sample = if_else(grepl("KB2", sample), 'Lcc', sample)) %>%
  mutate(sample = if_else(grepl("NB1", sample), 'Hcc', sample)) %>%
  mutate(sample = if_else(grepl("NB2", sample), 'Hcc', sample)) %>%
  group_by(project, run, assembler, orf_caller, bbnorm, minlen, sample, orf) %>%
  summarise(m_tpm = mean(tpm),
            sd = sd(tpm), 
            .groups = 'drop') %>%
  left_join( eukulele, by = join_by(project, run, assembler, orf_caller, bbnorm, minlen, orf) ) %>%
  filter( run == 'megahit.prokka.without_bbnorm')
counts.tax$family[is.na(counts.tax$family)] <- 'uncl.'

# calculate tpms Family level for bacteria
# top 7 family
top7_family <- counts.tax %>%
  filter( family != 'uncl.') %>%
  group_by(family) %>%
  summarise(tpm = sum(m_tpm), .groups = 'drop') %>%
  slice_max(tpm, n = 7) %>%
  select(-tpm)
  
RANKS.family.tax = c('Schleiferiaceae', 'Flavobacteriaceae', 'Pseudohongiellaceae', 'Alteromonadaceae', 'Thalassospiraceae', 'Pelagibacteraceae', 'Rhodobacteraceae')
matchcol.taxonomy <- c( "#962d19", "#BA5019", "#f8b53f",
                                   "#bae53f", "#4e3484", "#4e4e84", "#675084")
RANKS.original.tax = c("Other Flavobacteria", "Flavobacteriaceae", "Other Gammaproteobacteria", "Alteromonadaceae", "Other Alphaproteobacteria", "SAR11 clade", "Rhodobacteraceae")

matchingcolors.original.tax <- c("#952720", "#BA5019", "#F8E53F",
                                 "#bae53f", "#113484", "#115084","#675084")
# Schleiferiaceae     = #962d19
# Flavobacteriaceae   = #BA5019
# Pseudohongiellaceae = #f8b53f
# Alteromonadaceae    = #bae53f
# Thalassospiraceae   = #4e3484
# Pelagibacteraceae   = #4e4e84
# Rhodobacteraceae    = #675084

p7 <- ( counts.tax %>%
  inner_join(top7_family, by = "family") %>%
  group_by(sample, family) %>%
  summarise(sum_tpm = sum(m_tpm)/10^5, .groups = 'drop') %>%
  ggplot(aes(x = sample, y = sum_tpm, fill = factor(family, levels = RANKS.family.tax))) +
  scale_fill_manual(values = matchcol.taxonomy) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1, size = 10),
        legend.position = 'none') +
  ylab("Transcripts per million") +
  scale_y_continuous(breaks = seq(0, 8, by = 2), limits = c(0, 8)) +
  geom_col(width= .70, colour="black") +
  labs(x = NULL, fill = "Family", y ="TPM (x10^5)") ) +
  ( original.tax %>%
    ggplot(aes(x = sample, y = tpm, fill = factor(family, levels = RANKS.original.tax))) +
    scale_fill_manual(values = matchingcolors.original.tax) +
    scale_y_continuous(breaks = seq(0, 8, by = 2), limits = c(0, 8)) +
    theme(axis.text.x = element_text(angle = 45, hjust = 1, size = 10),
          legend.key.width = unit(0.5, "cm"),
        legend.key.height = unit(0.5, "cm")) +
    geom_col(width= .70, colour="black") +
    ylab("Transcripts per million") +
    labs(fill = "Family", y = "CPM (x10^5)", x = NULL)
  )

(p7 / p3 / (p5 + p6) ) + plot_annotation(tag_levels = 'A')
```

# Discussion

# References
